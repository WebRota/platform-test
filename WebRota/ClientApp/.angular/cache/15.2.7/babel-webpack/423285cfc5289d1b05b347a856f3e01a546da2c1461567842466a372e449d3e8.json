{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport { Injectable, NgZone, ɵɵdefineInjectable, ɵɵinject, InjectionToken, Optional, Inject, LOCALE_ID, Directive, Input, EventEmitter, Output, Self, Component, ElementRef, PLATFORM_ID, ContentChildren, QueryList, forwardRef, NgModule } from '@angular/core';\nimport { Observable, BehaviorSubject, from, timer, ReplaySubject, bindCallback, of, throwError, fromEventPattern, merge, Subject } from 'rxjs';\nimport { flatMap, sample, switchMap, map, shareReplay, multicast, startWith, skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { isPlatformServer } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"*\"];\nlet MapsAPILoader = /*#__PURE__*/(() => {\n  class MapsAPILoader {}\n  MapsAPILoader.ɵfac = function MapsAPILoader_Factory(t) {\n    return new (t || MapsAPILoader)();\n  };\n  MapsAPILoader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MapsAPILoader,\n    factory: MapsAPILoader.ɵfac\n  });\n  return MapsAPILoader;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Wrapper class that handles the communication with the Google Maps Javascript\n * API v3\n */\nlet GoogleMapsAPIWrapper = /*#__PURE__*/(() => {\n  class GoogleMapsAPIWrapper {\n    constructor(_loader, _zone) {\n      this._loader = _loader;\n      this._zone = _zone;\n      this._map = new Promise(resolve => {\n        this._mapResolver = resolve;\n      });\n    }\n    createMap(el, mapOptions) {\n      return this._zone.runOutsideAngular(() => {\n        return this._loader.load().then(() => {\n          const map = new google.maps.Map(el, mapOptions);\n          this._mapResolver(map);\n          return;\n        });\n      });\n    }\n    setMapOptions(options) {\n      return this._zone.runOutsideAngular(() => {\n        this._map.then(m => {\n          m.setOptions(options);\n        });\n      });\n    }\n    /**\n     * Creates a google map marker with the map context\n     */\n    createMarker(options = {}, addToMap = true) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => {\n          if (addToMap) {\n            options.map = map;\n          }\n          return new google.maps.Marker(options);\n        });\n      });\n    }\n    createInfoWindow(options) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(() => new google.maps.InfoWindow(options));\n      });\n    }\n    /**\n     * Creates a google.map.Circle for the current map.\n     */\n    createCircle(options) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => {\n          options.map = map;\n          return new google.maps.Circle(options);\n        });\n      });\n    }\n    /**\n     * Creates a google.map.Rectangle for the current map.\n     */\n    createRectangle(options) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => {\n          options.map = map;\n          return new google.maps.Rectangle(options);\n        });\n      });\n    }\n    createPolyline(options) {\n      return this._zone.runOutsideAngular(() => {\n        return this.getNativeMap().then(map => {\n          const line = new google.maps.Polyline(options);\n          line.setMap(map);\n          return line;\n        });\n      });\n    }\n    createPolygon(options) {\n      return this._zone.runOutsideAngular(() => {\n        return this.getNativeMap().then(map => {\n          const polygon = new google.maps.Polygon(options);\n          polygon.setMap(map);\n          return polygon;\n        });\n      });\n    }\n    /**\n     * Creates a new google.map.Data layer for the current map\n     */\n    createDataLayer(options) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(m => {\n          const data = new google.maps.Data(options);\n          data.setMap(m);\n          return data;\n        });\n      });\n    }\n    /**\n     * Creates a TransitLayer instance for a map\n     * @returns a new transit layer object\n     */\n    createTransitLayer() {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => {\n          const newLayer = new google.maps.TransitLayer();\n          newLayer.setMap(map);\n          return newLayer;\n        });\n      });\n    }\n    /**\n     * Creates a BicyclingLayer instance for a map\n     * @returns a new bicycling layer object\n     */\n    createBicyclingLayer() {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => {\n          const newLayer = new google.maps.BicyclingLayer();\n          newLayer.setMap(map);\n          return newLayer;\n        });\n      });\n    }\n    /**\n     * Determines if given coordinates are insite a Polygon path.\n     */\n    containsLocation(latLng, polygon) {\n      return this._map.then(() => google.maps.geometry.poly.containsLocation(latLng, polygon));\n    }\n    subscribeToMapEvent(eventName) {\n      return new Observable(observer => {\n        this._map.then(m => m.addListener(eventName, () => this._zone.run(() => observer.next(arguments[0]))));\n      });\n    }\n    clearInstanceListeners() {\n      return this._zone.runOutsideAngular(() => {\n        this._map.then(map => {\n          google.maps.event.clearInstanceListeners(map);\n        });\n      });\n    }\n    setCenter(latLng) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.setCenter(latLng));\n      });\n    }\n    getZoom() {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.getZoom());\n      });\n    }\n    getBounds() {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.getBounds());\n      });\n    }\n    getMapTypeId() {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.getMapTypeId());\n      });\n    }\n    setZoom(zoom) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.setZoom(zoom));\n      });\n    }\n    getCenter() {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.getCenter());\n      });\n    }\n    panTo(latLng) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.panTo(latLng));\n      });\n    }\n    panBy(x, y) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.panBy(x, y));\n      });\n    }\n    fitBounds(latLng, padding) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.fitBounds(latLng, padding));\n      });\n    }\n    panToBounds(latLng, padding) {\n      return this._zone.runOutsideAngular(() => {\n        return this._map.then(map => map.panToBounds(latLng, padding));\n      });\n    }\n    /**\n     * Returns the native Google Maps Map instance. Be careful when using this instance directly.\n     */\n    getNativeMap() {\n      return this._map;\n    }\n    /**\n     * Triggers the given event name on the map instance.\n     */\n    triggerMapEvent(eventName) {\n      return this._map.then(m => google.maps.event.trigger(m, eventName));\n    }\n  }\n  GoogleMapsAPIWrapper.ɵfac = function GoogleMapsAPIWrapper_Factory(t) {\n    return new (t || GoogleMapsAPIWrapper)(ɵngcc0.ɵɵinject(MapsAPILoader), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  GoogleMapsAPIWrapper.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: GoogleMapsAPIWrapper,\n    factory: GoogleMapsAPIWrapper.ɵfac\n  });\n  return GoogleMapsAPIWrapper;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CircleManager = /*#__PURE__*/(() => {\n  class CircleManager {\n    constructor(_apiWrapper, _zone) {\n      this._apiWrapper = _apiWrapper;\n      this._zone = _zone;\n      this._circles = new Map();\n    }\n    addCircle(circle) {\n      this._apiWrapper.getNativeMap().then(() => this._circles.set(circle, this._apiWrapper.createCircle({\n        center: {\n          lat: circle.latitude,\n          lng: circle.longitude\n        },\n        clickable: circle.clickable,\n        draggable: circle.draggable,\n        editable: circle.editable,\n        fillColor: circle.fillColor,\n        fillOpacity: circle.fillOpacity,\n        radius: circle.radius,\n        strokeColor: circle.strokeColor,\n        strokeOpacity: circle.strokeOpacity,\n        strokePosition: google.maps.StrokePosition[circle.strokePosition],\n        strokeWeight: circle.strokeWeight,\n        visible: circle.visible,\n        zIndex: circle.zIndex\n      })));\n    }\n    /**\n     * Removes the given circle from the map.\n     */\n    removeCircle(circle) {\n      return this._circles.get(circle).then(c => {\n        c.setMap(null);\n        this._circles.delete(circle);\n      });\n    }\n    setOptions(circle, options) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return this._circles.get(circle).then(c => {\n          const actualParam = options.strokePosition;\n          options.strokePosition = google.maps.StrokePosition[actualParam];\n          c.setOptions(options);\n        });\n      });\n    }\n    getBounds(circle) {\n      return this._circles.get(circle).then(c => c.getBounds());\n    }\n    getCenter(circle) {\n      return this._circles.get(circle).then(c => c.getCenter());\n    }\n    getRadius(circle) {\n      return this._circles.get(circle).then(c => c.getRadius());\n    }\n    setCenter(circle) {\n      return this._circles.get(circle).then(c => c.setCenter({\n        lat: circle.latitude,\n        lng: circle.longitude\n      }));\n    }\n    setEditable(circle) {\n      return this._circles.get(circle).then(c => c.setEditable(circle.editable));\n    }\n    setDraggable(circle) {\n      return this._circles.get(circle).then(c => c.setDraggable(circle.draggable));\n    }\n    setVisible(circle) {\n      return this._circles.get(circle).then(c => c.setVisible(circle.visible));\n    }\n    setRadius(circle) {\n      return this._circles.get(circle).then(c => c.setRadius(circle.radius));\n    }\n    getNativeCircle(circle) {\n      return this._circles.get(circle);\n    }\n    createEventObservable(eventName, circle) {\n      return new Observable(observer => {\n        let listener = null;\n        this._circles.get(circle).then(c => {\n          listener = c.addListener(eventName, e => this._zone.run(() => observer.next(e)));\n        });\n        return () => {\n          if (listener !== null) {\n            listener.remove();\n          }\n        };\n      });\n    }\n  }\n  CircleManager.ɵfac = function CircleManager_Factory(t) {\n    return new (t || CircleManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  CircleManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: CircleManager,\n    factory: CircleManager.ɵfac\n  });\n  return CircleManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Manages all Data Layers for a Google Map instance.\n */\nlet DataLayerManager = /*#__PURE__*/(() => {\n  class DataLayerManager {\n    constructor(_wrapper, _zone) {\n      this._wrapper = _wrapper;\n      this._zone = _zone;\n      this._layers = new Map();\n    }\n    /**\n     * Adds a new Data Layer to the map.\n     */\n    addDataLayer(layer) {\n      const newLayer = this._wrapper.createDataLayer({\n        style: layer.style\n      }).then(d => {\n        if (layer.geoJson) {\n          // NOTE: accessing \"features\" on google.maps.Data is undocumented\n          this.getDataFeatures(d, layer.geoJson).then(features => d.features = features);\n        }\n        return d;\n      });\n      this._layers.set(layer, newLayer);\n    }\n    deleteDataLayer(layer) {\n      this._layers.get(layer).then(l => {\n        l.setMap(null);\n        this._layers.delete(layer);\n      });\n    }\n    updateGeoJson(layer, geoJson) {\n      this._layers.get(layer).then(l => {\n        l.forEach(feature => {\n          l.remove(feature);\n          // NOTE: accessing \"features\" on google.maps.Data is undocumented\n          const index = l.features.indexOf(feature, 0);\n          if (index > -1) {\n            l.features.splice(index, 1);\n          }\n        });\n        this.getDataFeatures(l, geoJson).then(features => l.features = features);\n      });\n    }\n    setDataOptions(layer, options) {\n      this._layers.get(layer).then(l => {\n        l.setControlPosition(options.controlPosition);\n        l.setControls(options.controls);\n        l.setDrawingMode(options.drawingMode);\n        l.setStyle(options.style);\n      });\n    }\n    /**\n     * Creates a Google Maps event listener for the given DataLayer as an Observable\n     */\n    createEventObservable(eventName, layer) {\n      return new Observable(observer => {\n        this._layers.get(layer).then(d => {\n          d.addListener(eventName, e => this._zone.run(() => observer.next(e)));\n        });\n      });\n    }\n    /**\n     * Extract features from a geoJson using google.maps Data Class\n     * @param d : google.maps.Data class instance\n     * @param geoJson : url or geojson object\n     */\n    getDataFeatures(d, geoJson) {\n      return new Promise((resolve, reject) => {\n        if (typeof geoJson === 'object') {\n          try {\n            const features = d.addGeoJson(geoJson);\n            resolve(features);\n          } catch (e) {\n            reject(e);\n          }\n        } else if (typeof geoJson === 'string') {\n          d.loadGeoJson(geoJson, null, resolve);\n        } else {\n          reject(`Impossible to extract features from geoJson: wrong argument type`);\n        }\n      });\n    }\n  }\n  DataLayerManager.ɵfac = function DataLayerManager_Factory(t) {\n    return new (t || DataLayerManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  DataLayerManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DataLayerManager,\n    factory: DataLayerManager.ɵfac\n  });\n  return DataLayerManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Class to implement when you what to be able to make it work with the auto fit bounds feature\n * of AGM.\n */\nclass FitBoundsAccessor {}\n/**\n * The FitBoundsService is responsible for computing the bounds of the a single map.\n */\nlet FitBoundsService = /*#__PURE__*/(() => {\n  class FitBoundsService {\n    constructor(loader) {\n      this._boundsChangeSampleTime$ = new BehaviorSubject(200);\n      this._includeInBounds$ = new BehaviorSubject(new Map());\n      this.bounds$ = from(loader.load()).pipe(flatMap(() => this._includeInBounds$), sample(this._boundsChangeSampleTime$.pipe(switchMap(time => timer(0, time)))), map(includeInBounds => this._generateBounds(includeInBounds)), shareReplay(1));\n    }\n    _generateBounds(includeInBounds) {\n      const bounds = new google.maps.LatLngBounds();\n      includeInBounds.forEach(b => bounds.extend(b));\n      return bounds;\n    }\n    addToBounds(latLng) {\n      const id = this._createIdentifier(latLng);\n      if (this._includeInBounds$.value.has(id)) {\n        return;\n      }\n      const boundsMap = this._includeInBounds$.value;\n      boundsMap.set(id, latLng);\n      this._includeInBounds$.next(boundsMap);\n    }\n    removeFromBounds(latLng) {\n      const boundsMap = this._includeInBounds$.value;\n      boundsMap.delete(this._createIdentifier(latLng));\n      this._includeInBounds$.next(boundsMap);\n    }\n    changeFitBoundsChangeSampleTime(timeMs) {\n      this._boundsChangeSampleTime$.next(timeMs);\n    }\n    getBounds$() {\n      return this.bounds$;\n    }\n    _createIdentifier(latLng) {\n      return `${latLng.lat}+${latLng.lng}`;\n    }\n  }\n  FitBoundsService.ɵfac = function FitBoundsService_Factory(t) {\n    return new (t || FitBoundsService)(ɵngcc0.ɵɵinject(MapsAPILoader));\n  };\n  FitBoundsService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: FitBoundsService,\n    factory: FitBoundsService.ɵfac\n  });\n  return FitBoundsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmGeocoder = /*#__PURE__*/(() => {\n  class AgmGeocoder {\n    constructor(loader) {\n      const connectableGeocoder$ = new Observable(subscriber => {\n        loader.load().then(() => subscriber.next());\n      }).pipe(map(() => this._createGeocoder()), multicast(new ReplaySubject(1)));\n      connectableGeocoder$.connect(); // ignore the subscription\n      // since we will remain subscribed till application exits\n      this.geocoder$ = connectableGeocoder$;\n    }\n    geocode(request) {\n      return this.geocoder$.pipe(switchMap(geocoder => this._getGoogleResults(geocoder, request)));\n    }\n    _getGoogleResults(geocoder, request) {\n      const geocodeObservable = bindCallback(geocoder.geocode);\n      return geocodeObservable(request).pipe(switchMap(([results, status]) => {\n        if (status === google.maps.GeocoderStatus.OK) {\n          return of(results);\n        }\n        return throwError(status);\n      }));\n    }\n    _createGeocoder() {\n      return new google.maps.Geocoder();\n    }\n  }\n  AgmGeocoder.ɵfac = function AgmGeocoder_Factory(t) {\n    return new (t || AgmGeocoder)(ɵngcc0.ɵɵinject(MapsAPILoader));\n  };\n  AgmGeocoder.ɵprov = ɵɵdefineInjectable({\n    factory: function AgmGeocoder_Factory() {\n      return new AgmGeocoder(ɵɵinject(MapsAPILoader));\n    },\n    token: AgmGeocoder,\n    providedIn: \"root\"\n  });\n  return AgmGeocoder;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass WindowRef {\n  getNativeWindow() {\n    return window;\n  }\n}\nclass DocumentRef {\n  getNativeDocument() {\n    return document;\n  }\n}\nconst BROWSER_GLOBALS_PROVIDERS = [WindowRef, DocumentRef];\nvar GoogleMapsScriptProtocol = /*#__PURE__*/(() => {\n  (function (GoogleMapsScriptProtocol) {\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"HTTP\"] = 1] = \"HTTP\";\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"HTTPS\"] = 2] = \"HTTPS\";\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"AUTO\"] = 3] = \"AUTO\";\n  })(GoogleMapsScriptProtocol || (GoogleMapsScriptProtocol = {}));\n  return GoogleMapsScriptProtocol;\n})();\n/**\n * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link\n * LazyMapsAPILoaderConfig}.\n */\nconst LAZY_MAPS_API_CONFIG = new InjectionToken('angular-google-maps LAZY_MAPS_API_CONFIG');\nlet LazyMapsAPILoader = /*#__PURE__*/(() => {\n  class LazyMapsAPILoader extends MapsAPILoader {\n    constructor(config = null, w, d, localeId) {\n      super();\n      this.localeId = localeId;\n      this._SCRIPT_ID = 'agmGoogleMapsApiScript';\n      this.callbackName = `agmLazyMapsAPILoader`;\n      this._config = config || {};\n      this._windowRef = w;\n      this._documentRef = d;\n    }\n    load() {\n      const window = this._windowRef.getNativeWindow();\n      if (window.google && window.google.maps) {\n        // Google maps already loaded on the page.\n        return Promise.resolve();\n      }\n      if (this._scriptLoadingPromise) {\n        return this._scriptLoadingPromise;\n      }\n      // this can happen in HMR situations or Stackblitz.io editors.\n      const scriptOnPage = this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);\n      if (scriptOnPage) {\n        this._assignScriptLoadingPromise(scriptOnPage);\n        return this._scriptLoadingPromise;\n      }\n      const script = this._documentRef.getNativeDocument().createElement('script');\n      script.type = 'text/javascript';\n      script.async = true;\n      script.defer = true;\n      script.id = this._SCRIPT_ID;\n      script.src = this._getScriptSrc(this.callbackName);\n      this._assignScriptLoadingPromise(script);\n      this._documentRef.getNativeDocument().body.appendChild(script);\n      return this._scriptLoadingPromise;\n    }\n    _assignScriptLoadingPromise(scriptElem) {\n      this._scriptLoadingPromise = new Promise((resolve, reject) => {\n        this._windowRef.getNativeWindow()[this.callbackName] = () => {\n          resolve();\n        };\n        scriptElem.onerror = error => {\n          reject(error);\n        };\n      });\n    }\n    _getScriptSrc(callbackName) {\n      const protocolType = this._config && this._config.protocol || GoogleMapsScriptProtocol.HTTPS;\n      let protocol;\n      switch (protocolType) {\n        case GoogleMapsScriptProtocol.AUTO:\n          protocol = '';\n          break;\n        case GoogleMapsScriptProtocol.HTTP:\n          protocol = 'http:';\n          break;\n        case GoogleMapsScriptProtocol.HTTPS:\n          protocol = 'https:';\n          break;\n      }\n      const hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';\n      const queryParams = {\n        v: this._config.apiVersion || 'quarterly',\n        callback: callbackName,\n        key: this._config.apiKey,\n        client: this._config.clientId,\n        channel: this._config.channel,\n        libraries: this._config.libraries,\n        region: this._config.region,\n        language: this._config.language || (this.localeId !== 'en-US' ? this.localeId : null)\n      };\n      const params = Object.keys(queryParams).filter(k => queryParams[k] != null).filter(k => {\n        // remove empty arrays\n        return !Array.isArray(queryParams[k]) || Array.isArray(queryParams[k]) && queryParams[k].length > 0;\n      }).map(k => {\n        // join arrays as comma seperated strings\n        const i = queryParams[k];\n        if (Array.isArray(i)) {\n          return {\n            key: k,\n            value: i.join(',')\n          };\n        }\n        return {\n          key: k,\n          value: queryParams[k]\n        };\n      }).map(entry => {\n        return `${entry.key}=${entry.value}`;\n      }).join('&');\n      return `${protocol}//${hostAndPath}?${params}`;\n    }\n  }\n  LazyMapsAPILoader.ɵfac = function LazyMapsAPILoader_Factory(t) {\n    return new (t || LazyMapsAPILoader)(ɵngcc0.ɵɵinject(LAZY_MAPS_API_CONFIG, 8), ɵngcc0.ɵɵinject(WindowRef), ɵngcc0.ɵɵinject(DocumentRef), ɵngcc0.ɵɵinject(LOCALE_ID));\n  };\n  LazyMapsAPILoader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LazyMapsAPILoader,\n    factory: LazyMapsAPILoader.ɵfac\n  });\n  return LazyMapsAPILoader;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MarkerManager = /*#__PURE__*/(() => {\n  class MarkerManager {\n    constructor(_mapsWrapper, _zone) {\n      this._mapsWrapper = _mapsWrapper;\n      this._zone = _zone;\n      this._markers = new Map();\n    }\n    convertAnimation(uiAnim) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (uiAnim === null) {\n          return null;\n        } else {\n          return this._mapsWrapper.getNativeMap().then(() => google.maps.Animation[uiAnim]);\n        }\n      });\n    }\n    deleteMarker(markerDirective) {\n      const markerPromise = this._markers.get(markerDirective);\n      if (markerPromise == null) {\n        // marker already deleted\n        return Promise.resolve();\n      }\n      return markerPromise.then(marker => {\n        return this._zone.run(() => {\n          marker.setMap(null);\n          this._markers.delete(markerDirective);\n        });\n      });\n    }\n    updateMarkerPosition(marker) {\n      return this._markers.get(marker).then(m => m.setPosition({\n        lat: marker.latitude,\n        lng: marker.longitude\n      }));\n    }\n    updateTitle(marker) {\n      return this._markers.get(marker).then(m => m.setTitle(marker.title));\n    }\n    updateLabel(marker) {\n      return this._markers.get(marker).then(m => {\n        m.setLabel(marker.label);\n      });\n    }\n    updateDraggable(marker) {\n      return this._markers.get(marker).then(m => m.setDraggable(marker.draggable));\n    }\n    updateIcon(marker) {\n      return this._markers.get(marker).then(m => m.setIcon(marker.iconUrl));\n    }\n    updateOpacity(marker) {\n      return this._markers.get(marker).then(m => m.setOpacity(marker.opacity));\n    }\n    updateVisible(marker) {\n      return this._markers.get(marker).then(m => m.setVisible(marker.visible));\n    }\n    updateZIndex(marker) {\n      return this._markers.get(marker).then(m => m.setZIndex(marker.zIndex));\n    }\n    updateClickable(marker) {\n      return this._markers.get(marker).then(m => m.setClickable(marker.clickable));\n    }\n    updateAnimation(marker) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const m = yield this._markers.get(marker);\n        m.setAnimation(yield this.convertAnimation(marker.animation));\n      });\n    }\n    addMarker(marker) {\n      const markerPromise = new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n        return this._mapsWrapper.createMarker({\n          position: {\n            lat: marker.latitude,\n            lng: marker.longitude\n          },\n          label: marker.label,\n          draggable: marker.draggable,\n          icon: marker.iconUrl,\n          opacity: marker.opacity,\n          visible: marker.visible,\n          zIndex: marker.zIndex,\n          title: marker.title,\n          clickable: marker.clickable,\n          animation: yield this.convertAnimation(marker.animation)\n        }).then(resolve);\n      }));\n      this._markers.set(marker, markerPromise);\n    }\n    getNativeMarker(marker) {\n      return this._markers.get(marker);\n    }\n    createEventObservable(eventName, marker) {\n      return new Observable(observer => {\n        this._markers.get(marker).then(m => m.addListener(eventName, e => this._zone.run(() => observer.next(e))));\n      });\n    }\n  }\n  MarkerManager.ɵfac = function MarkerManager_Factory(t) {\n    return new (t || MarkerManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  MarkerManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MarkerManager,\n    factory: MarkerManager.ɵfac\n  });\n  return MarkerManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InfoWindowManager = /*#__PURE__*/(() => {\n  class InfoWindowManager {\n    constructor(_mapsWrapper, _zone, _markerManager) {\n      this._mapsWrapper = _mapsWrapper;\n      this._zone = _zone;\n      this._markerManager = _markerManager;\n      this._infoWindows = new Map();\n    }\n    deleteInfoWindow(infoWindow) {\n      const iWindow = this._infoWindows.get(infoWindow);\n      if (iWindow == null) {\n        // info window already deleted\n        return Promise.resolve();\n      }\n      return iWindow.then(i => {\n        return this._zone.run(() => {\n          i.close();\n          this._infoWindows.delete(infoWindow);\n        });\n      });\n    }\n    setPosition(infoWindow) {\n      return this._infoWindows.get(infoWindow).then(i => i.setPosition({\n        lat: infoWindow.latitude,\n        lng: infoWindow.longitude\n      }));\n    }\n    setZIndex(infoWindow) {\n      return this._infoWindows.get(infoWindow).then(i => i.setZIndex(infoWindow.zIndex));\n    }\n    open(infoWindow) {\n      return this._infoWindows.get(infoWindow).then(w => {\n        if (infoWindow.hostMarker != null) {\n          return this._markerManager.getNativeMarker(infoWindow.hostMarker).then(marker => {\n            return this._mapsWrapper.getNativeMap().then(map => w.open(map, marker));\n          });\n        }\n        return this._mapsWrapper.getNativeMap().then(map => w.open(map));\n      });\n    }\n    close(infoWindow) {\n      return this._infoWindows.get(infoWindow).then(w => w.close());\n    }\n    setOptions(infoWindow, options) {\n      return this._infoWindows.get(infoWindow).then(i => i.setOptions(options));\n    }\n    addInfoWindow(infoWindow) {\n      const options = {\n        content: infoWindow.content,\n        maxWidth: infoWindow.maxWidth,\n        zIndex: infoWindow.zIndex,\n        disableAutoPan: infoWindow.disableAutoPan\n      };\n      if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {\n        options.position = {\n          lat: infoWindow.latitude,\n          lng: infoWindow.longitude\n        };\n      }\n      const infoWindowPromise = this._mapsWrapper.createInfoWindow(options);\n      this._infoWindows.set(infoWindow, infoWindowPromise);\n    }\n    /**\n     * Creates a Google Maps event listener for the given InfoWindow as an Observable\n     */\n    createEventObservable(eventName, infoWindow) {\n      return new Observable(observer => {\n        this._infoWindows.get(infoWindow).then(i => {\n          i.addListener(eventName, e => this._zone.run(() => observer.next(e)));\n        });\n      });\n    }\n  }\n  InfoWindowManager.ɵfac = function InfoWindowManager_Factory(t) {\n    return new (t || InfoWindowManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(MarkerManager));\n  };\n  InfoWindowManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: InfoWindowManager,\n    factory: InfoWindowManager.ɵfac\n  });\n  return InfoWindowManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Manages all KML Layers for a Google Map instance.\n */\nlet KmlLayerManager = /*#__PURE__*/(() => {\n  class KmlLayerManager {\n    constructor(_wrapper, _zone) {\n      this._wrapper = _wrapper;\n      this._zone = _zone;\n      this._layers = new Map();\n    }\n    /**\n     * Adds a new KML Layer to the map.\n     */\n    addKmlLayer(layer) {\n      const newLayer = this._wrapper.getNativeMap().then(m => {\n        return new google.maps.KmlLayer({\n          clickable: layer.clickable,\n          map: m,\n          preserveViewport: layer.preserveViewport,\n          screenOverlays: layer.screenOverlays,\n          suppressInfoWindows: layer.suppressInfoWindows,\n          url: layer.url,\n          zIndex: layer.zIndex\n        });\n      });\n      this._layers.set(layer, newLayer);\n    }\n    setOptions(layer, options) {\n      this._layers.get(layer).then(l => l.setOptions(options));\n    }\n    deleteKmlLayer(layer) {\n      this._layers.get(layer).then(l => {\n        l.setMap(null);\n        this._layers.delete(layer);\n      });\n    }\n    /**\n     * Creates a Google Maps event listener for the given KmlLayer as an Observable\n     */\n    createEventObservable(eventName, layer) {\n      return new Observable(observer => {\n        this._layers.get(layer).then(m => {\n          m.addListener(eventName, e => this._zone.run(() => observer.next(e)));\n        });\n      });\n    }\n  }\n  KmlLayerManager.ɵfac = function KmlLayerManager_Factory(t) {\n    return new (t || KmlLayerManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  KmlLayerManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: KmlLayerManager,\n    factory: KmlLayerManager.ɵfac\n  });\n  return KmlLayerManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * This class manages Transit and Bicycling Layers for a Google Map instance.\n */\nlet LayerManager = /*#__PURE__*/(() => {\n  class LayerManager {\n    constructor(_wrapper) {\n      this._wrapper = _wrapper;\n      this._layers = new Map();\n    }\n    /**\n     * Adds a transit layer to a map instance.\n     * @param layer - a TransitLayer object\n     * @param _options - TransitLayerOptions options\n     * @returns void\n     */\n    addTransitLayer(layer) {\n      const newLayer = this._wrapper.createTransitLayer();\n      this._layers.set(layer, newLayer);\n    }\n    /**\n     * Adds a bicycling layer to a map instance.\n     * @param layer - a bicycling layer object\n     * @param _options - BicyclingLayer options\n     * @returns void\n     */\n    addBicyclingLayer(layer) {\n      const newLayer = this._wrapper.createBicyclingLayer();\n      this._layers.set(layer, newLayer);\n    }\n    /**\n     * Deletes a map layer\n     * @param layer - the layer to delete\n     */\n    deleteLayer(layer) {\n      return this._layers.get(layer).then(currentLayer => {\n        currentLayer.setMap(null);\n        this._layers.delete(layer);\n      });\n    }\n  }\n  LayerManager.ɵfac = function LayerManager_Factory(t) {\n    return new (t || LayerManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper));\n  };\n  LayerManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LayerManager,\n    factory: LayerManager.ɵfac\n  });\n  return LayerManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`\n * Tag.\n * It's important that the Google Maps API script gets loaded first on the page.\n */\nclass NoOpMapsAPILoader {\n  load() {\n    if (!window.google || !window.google.maps) {\n      throw new Error('Google Maps API not loaded on page. Make sure window.google.maps is available!');\n    }\n    return Promise.resolve();\n  }\n}\nfunction createMVCEventObservable(array) {\n  const eventNames = ['insert_at', 'remove_at', 'set_at'];\n  return fromEventPattern(handler => eventNames.map(eventName => array.addListener(eventName, (index, previous) => handler.apply(array, [{\n    newArr: array.getArray(),\n    eventName,\n    index,\n    previous\n  }]))), (_handler, evListeners) => evListeners.forEach(evListener => evListener.remove()));\n}\nclass MvcArrayMock {\n  constructor() {\n    this.vals = [];\n    this.listeners = {\n      remove_at: [],\n      insert_at: [],\n      set_at: []\n    };\n  }\n  clear() {\n    for (let i = this.vals.length - 1; i >= 0; i--) {\n      this.removeAt(i);\n    }\n  }\n  getArray() {\n    return [...this.vals];\n  }\n  getAt(i) {\n    return this.vals[i];\n  }\n  getLength() {\n    return this.vals.length;\n  }\n  insertAt(i, elem) {\n    this.vals.splice(i, 0, elem);\n    this.listeners.insert_at.forEach(listener => listener(i));\n  }\n  pop() {\n    const deleted = this.vals.pop();\n    this.listeners.remove_at.forEach(listener => listener(this.vals.length, deleted));\n    return deleted;\n  }\n  push(elem) {\n    this.vals.push(elem);\n    this.listeners.insert_at.forEach(listener => listener(this.vals.length - 1));\n    return this.vals.length;\n  }\n  removeAt(i) {\n    const deleted = this.vals.splice(i, 1)[0];\n    this.listeners.remove_at.forEach(listener => listener(i, deleted));\n    return deleted;\n  }\n  setAt(i, elem) {\n    const deleted = this.vals[i];\n    this.vals[i] = elem;\n    this.listeners.set_at.forEach(listener => listener(i, deleted));\n  }\n  forEach(callback) {\n    this.vals.forEach(callback);\n  }\n  addListener(eventName, handler) {\n    const listenerArr = this.listeners[eventName];\n    listenerArr.push(handler);\n    return {\n      remove: () => {\n        listenerArr.splice(listenerArr.indexOf(handler), 1);\n      }\n    };\n  }\n  bindTo() {\n    throw new Error('Not implemented');\n  }\n  changed() {\n    throw new Error('Not implemented');\n  }\n  get() {\n    throw new Error('Not implemented');\n  }\n  notify() {\n    throw new Error('Not implemented');\n  }\n  set() {\n    throw new Error('Not implemented');\n  }\n  setValues() {\n    throw new Error('Not implemented');\n  }\n  unbind() {\n    throw new Error('Not implemented');\n  }\n  unbindAll() {\n    throw new Error('Not implemented');\n  }\n}\nlet PolygonManager = /*#__PURE__*/(() => {\n  class PolygonManager {\n    constructor(_mapsWrapper, _zone) {\n      this._mapsWrapper = _mapsWrapper;\n      this._zone = _zone;\n      this._polygons = new Map();\n    }\n    addPolygon(path) {\n      const polygonPromise = this._mapsWrapper.createPolygon({\n        clickable: path.clickable,\n        draggable: path.draggable,\n        editable: path.editable,\n        fillColor: path.fillColor,\n        fillOpacity: path.fillOpacity,\n        geodesic: path.geodesic,\n        paths: path.paths,\n        strokeColor: path.strokeColor,\n        strokeOpacity: path.strokeOpacity,\n        strokeWeight: path.strokeWeight,\n        visible: path.visible,\n        zIndex: path.zIndex\n      });\n      this._polygons.set(path, polygonPromise);\n    }\n    updatePolygon(polygon) {\n      const m = this._polygons.get(polygon);\n      if (m == null) {\n        return Promise.resolve();\n      }\n      return m.then(l => this._zone.run(() => {\n        l.setPaths(polygon.paths);\n      }));\n    }\n    setPolygonOptions(path, options) {\n      return this._polygons.get(path).then(l => {\n        l.setOptions(options);\n      });\n    }\n    deletePolygon(paths) {\n      const m = this._polygons.get(paths);\n      if (m == null) {\n        return Promise.resolve();\n      }\n      return m.then(l => {\n        return this._zone.run(() => {\n          l.setMap(null);\n          this._polygons.delete(paths);\n        });\n      });\n    }\n    getPath(polygonDirective) {\n      return this._polygons.get(polygonDirective).then(polygon => polygon.getPath().getArray());\n    }\n    getPaths(polygonDirective) {\n      return this._polygons.get(polygonDirective).then(polygon => polygon.getPaths().getArray().map(p => p.getArray()));\n    }\n    createEventObservable(eventName, path) {\n      return new Observable(observer => {\n        this._polygons.get(path).then(l => {\n          l.addListener(eventName, e => this._zone.run(() => observer.next(e)));\n        });\n      });\n    }\n    createPathEventObservable(agmPolygon) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const polygon = yield this._polygons.get(agmPolygon);\n        const paths = polygon.getPaths();\n        const pathsChanges$ = createMVCEventObservable(paths);\n        return pathsChanges$.pipe(startWith({\n          newArr: paths.getArray()\n        }),\n        // in order to subscribe to them all\n        switchMap(parentMVEvent => merge(...\n        // rest parameter\n        parentMVEvent.newArr.map((chMVC, index) => createMVCEventObservable(chMVC).pipe(map(chMVCEvent => ({\n          parentMVEvent,\n          chMVCEvent,\n          pathIndex: index\n        }))))).pipe(\n        // start the merged ob with an event signinifing change to parent\n        startWith({\n          parentMVEvent,\n          chMVCEvent: null,\n          pathIndex: null\n        }))), skip(1),\n        // skip the manually added event\n        map(({\n          parentMVEvent,\n          chMVCEvent,\n          pathIndex\n        }) => {\n          let retVal;\n          if (!chMVCEvent) {\n            retVal = {\n              newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),\n              eventName: parentMVEvent.eventName,\n              index: parentMVEvent.index\n            };\n            if (parentMVEvent.previous) {\n              retVal.previous = parentMVEvent.previous.getArray();\n            }\n          } else {\n            retVal = {\n              newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),\n              pathIndex,\n              eventName: chMVCEvent.eventName,\n              index: chMVCEvent.index\n            };\n            if (chMVCEvent.previous) {\n              retVal.previous = chMVCEvent.previous;\n            }\n          }\n          return retVal;\n        }));\n      });\n    }\n  }\n  PolygonManager.ɵfac = function PolygonManager_Factory(t) {\n    return new (t || PolygonManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  PolygonManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PolygonManager,\n    factory: PolygonManager.ɵfac\n  });\n  return PolygonManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PolylineManager = /*#__PURE__*/(() => {\n  class PolylineManager {\n    constructor(_mapsWrapper, _zone) {\n      this._mapsWrapper = _mapsWrapper;\n      this._zone = _zone;\n      this._polylines = new Map();\n    }\n    static _convertPoints(line) {\n      const path = line._getPoints().map(point => {\n        return {\n          lat: point.latitude,\n          lng: point.longitude\n        };\n      });\n      return path;\n    }\n    static _convertPath(path) {\n      const symbolPath = google.maps.SymbolPath[path];\n      if (typeof symbolPath === 'number') {\n        return symbolPath;\n      } else {\n        return path;\n      }\n    }\n    static _convertIcons(line) {\n      const icons = line._getIcons().map(agmIcon => ({\n        fixedRotation: agmIcon.fixedRotation,\n        offset: agmIcon.offset,\n        repeat: agmIcon.repeat,\n        icon: {\n          anchor: new google.maps.Point(agmIcon.anchorX, agmIcon.anchorY),\n          fillColor: agmIcon.fillColor,\n          fillOpacity: agmIcon.fillOpacity,\n          path: PolylineManager._convertPath(agmIcon.path),\n          rotation: agmIcon.rotation,\n          scale: agmIcon.scale,\n          strokeColor: agmIcon.strokeColor,\n          strokeOpacity: agmIcon.strokeOpacity,\n          strokeWeight: agmIcon.strokeWeight\n        }\n      }));\n      // prune undefineds;\n      icons.forEach(icon => {\n        Object.entries(icon).forEach(([key, val]) => {\n          if (typeof val === 'undefined') {\n            delete icon[key];\n          }\n        });\n        if (typeof icon.icon.anchor.x === 'undefined' || typeof icon.icon.anchor.y === 'undefined') {\n          delete icon.icon.anchor;\n        }\n      });\n      return icons;\n    }\n    addPolyline(line) {\n      const polylinePromise = this._mapsWrapper.getNativeMap().then(() => [PolylineManager._convertPoints(line), PolylineManager._convertIcons(line)]).then(([path, icons]) => this._mapsWrapper.createPolyline({\n        clickable: line.clickable,\n        draggable: line.draggable,\n        editable: line.editable,\n        geodesic: line.geodesic,\n        strokeColor: line.strokeColor,\n        strokeOpacity: line.strokeOpacity,\n        strokeWeight: line.strokeWeight,\n        visible: line.visible,\n        zIndex: line.zIndex,\n        path,\n        icons\n      }));\n      this._polylines.set(line, polylinePromise);\n    }\n    updatePolylinePoints(line) {\n      const path = PolylineManager._convertPoints(line);\n      const m = this._polylines.get(line);\n      if (m == null) {\n        return Promise.resolve();\n      }\n      return m.then(l => this._zone.run(() => l.setPath(path)));\n    }\n    updateIconSequences(line) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this._mapsWrapper.getNativeMap();\n        const icons = PolylineManager._convertIcons(line);\n        const m = this._polylines.get(line);\n        if (m == null) {\n          return;\n        }\n        return m.then(l => this._zone.run(() => l.setOptions({\n          icons\n        })));\n      });\n    }\n    setPolylineOptions(line, options) {\n      return this._polylines.get(line).then(l => {\n        l.setOptions(options);\n      });\n    }\n    deletePolyline(line) {\n      const m = this._polylines.get(line);\n      if (m == null) {\n        return Promise.resolve();\n      }\n      return m.then(l => {\n        return this._zone.run(() => {\n          l.setMap(null);\n          this._polylines.delete(line);\n        });\n      });\n    }\n    getMVCPath(agmPolyline) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const polyline = yield this._polylines.get(agmPolyline);\n        return polyline.getPath();\n      });\n    }\n    getPath(agmPolyline) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return (yield this.getMVCPath(agmPolyline)).getArray();\n      });\n    }\n    createEventObservable(eventName, line) {\n      return new Observable(observer => {\n        this._polylines.get(line).then(l => {\n          l.addListener(eventName, e => this._zone.run(() => observer.next(e)));\n        });\n      });\n    }\n    createPathEventObservable(line) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const mvcPath = yield this.getMVCPath(line);\n        return createMVCEventObservable(mvcPath);\n      });\n    }\n  }\n  PolylineManager.ɵfac = function PolylineManager_Factory(t) {\n    return new (t || PolylineManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  PolylineManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PolylineManager,\n    factory: PolylineManager.ɵfac\n  });\n  return PolylineManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RectangleManager = /*#__PURE__*/(() => {\n  class RectangleManager {\n    constructor(_apiWrapper, _zone) {\n      this._apiWrapper = _apiWrapper;\n      this._zone = _zone;\n      this._rectangles = new Map();\n    }\n    addRectangle(rectangle) {\n      this._apiWrapper.getNativeMap().then(() => this._rectangles.set(rectangle, this._apiWrapper.createRectangle({\n        bounds: {\n          north: rectangle.north,\n          east: rectangle.east,\n          south: rectangle.south,\n          west: rectangle.west\n        },\n        clickable: rectangle.clickable,\n        draggable: rectangle.draggable,\n        editable: rectangle.editable,\n        fillColor: rectangle.fillColor,\n        fillOpacity: rectangle.fillOpacity,\n        strokeColor: rectangle.strokeColor,\n        strokeOpacity: rectangle.strokeOpacity,\n        strokePosition: google.maps.StrokePosition[rectangle.strokePosition],\n        strokeWeight: rectangle.strokeWeight,\n        visible: rectangle.visible,\n        zIndex: rectangle.zIndex\n      })));\n    }\n    /**\n     * Removes the given rectangle from the map.\n     */\n    removeRectangle(rectangle) {\n      return this._rectangles.get(rectangle).then(r => {\n        r.setMap(null);\n        this._rectangles.delete(rectangle);\n      });\n    }\n    setOptions(rectangle, options) {\n      return this._rectangles.get(rectangle).then(r => {\n        const actualStrokePosition = options.strokePosition;\n        options.strokePosition = google.maps.StrokePosition[actualStrokePosition];\n        r.setOptions(options);\n      });\n    }\n    getBounds(rectangle) {\n      return this._rectangles.get(rectangle).then(r => r.getBounds());\n    }\n    setBounds(rectangle) {\n      return this._rectangles.get(rectangle).then(r => {\n        return r.setBounds({\n          north: rectangle.north,\n          east: rectangle.east,\n          south: rectangle.south,\n          west: rectangle.west\n        });\n      });\n    }\n    setEditable(rectangle) {\n      return this._rectangles.get(rectangle).then(r => {\n        return r.setEditable(rectangle.editable);\n      });\n    }\n    setDraggable(rectangle) {\n      return this._rectangles.get(rectangle).then(r => {\n        return r.setDraggable(rectangle.draggable);\n      });\n    }\n    setVisible(rectangle) {\n      return this._rectangles.get(rectangle).then(r => {\n        return r.setVisible(rectangle.visible);\n      });\n    }\n    createEventObservable(eventName, rectangle) {\n      return new Observable(subsrciber => {\n        let listener = null;\n        this._rectangles.get(rectangle).then(r => {\n          listener = r.addListener(eventName, e => this._zone.run(() => subsrciber.next(e)));\n        });\n        return () => {\n          if (listener !== null) {\n            listener.remove();\n          }\n        };\n      });\n    }\n  }\n  RectangleManager.ɵfac = function RectangleManager_Factory(t) {\n    return new (t || RectangleManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  RectangleManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: RectangleManager,\n    factory: RectangleManager.ɵfac\n  });\n  return RectangleManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet layerId = 0;\n/*\n * This directive adds a bicycling layer to a google map instance\n * <agm-bicycling-layer [visible]=\"true|false\"> <agm-bicycling-layer>\n * */\nlet AgmBicyclingLayer = /*#__PURE__*/(() => {\n  class AgmBicyclingLayer {\n    constructor(_manager) {\n      this._manager = _manager;\n      this._addedToManager = false;\n      this._id = (layerId++).toString();\n      /**\n       * Hide/show bicycling layer\n       */\n      this.visible = true;\n    }\n    ngOnInit() {\n      if (this._addedToManager) {\n        return;\n      }\n      this._manager.addBicyclingLayer(this);\n      this._addedToManager = true;\n    }\n    /** @internal */\n    id() {\n      return this._id;\n    }\n    /** @internal */\n    toString() {\n      return `AgmBicyclingLayer-${this._id.toString()}`;\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._manager.deleteLayer(this);\n    }\n  }\n  AgmBicyclingLayer.ɵfac = function AgmBicyclingLayer_Factory(t) {\n    return new (t || AgmBicyclingLayer)(ɵngcc0.ɵɵdirectiveInject(LayerManager));\n  };\n  AgmBicyclingLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmBicyclingLayer,\n    selectors: [[\"agm-bicycling-layer\"]],\n    inputs: {\n      visible: \"visible\"\n    }\n  });\n  return AgmBicyclingLayer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmCircle = /*#__PURE__*/(() => {\n  class AgmCircle {\n    constructor(_manager) {\n      this._manager = _manager;\n      /**\n       * Indicates whether this Circle handles mouse events. Defaults to true.\n       */\n      this.clickable = true;\n      /**\n       * If set to true, the user can drag this circle over the map. Defaults to false.\n       */\n      // tslint:disable-next-line:no-input-rename\n      this.draggable = false;\n      /**\n       * If set to true, the user can edit this circle by dragging the control points shown at\n       * the center and around the circumference of the circle. Defaults to false.\n       */\n      this.editable = false;\n      /**\n       * The radius in meters on the Earth's surface.\n       */\n      this.radius = 0;\n      /**\n       * The stroke position. Defaults to CENTER.\n       * This property is not supported on Internet Explorer 8 and earlier.\n       */\n      this.strokePosition = 'CENTER';\n      /**\n       * The stroke width in pixels.\n       */\n      this.strokeWeight = 0;\n      /**\n       * Whether this circle is visible on the map. Defaults to true.\n       */\n      this.visible = true;\n      /**\n       * This event is fired when the circle's center is changed.\n       */\n      this.centerChange = new EventEmitter();\n      /**\n       * This event emitter gets emitted when the user clicks on the circle.\n       */\n      this.circleClick = new EventEmitter();\n      /**\n       * This event emitter gets emitted when the user clicks on the circle.\n       */\n      this.circleDblClick = new EventEmitter();\n      /**\n       * This event is repeatedly fired while the user drags the circle.\n       */\n      // tslint:disable-next-line: no-output-native\n      this.drag = new EventEmitter();\n      /**\n       * This event is fired when the user stops dragging the circle.\n       */\n      this.dragEnd = new EventEmitter();\n      /**\n       * This event is fired when the user starts dragging the circle.\n       */\n      this.dragStart = new EventEmitter();\n      /**\n       * This event is fired when the DOM mousedown event is fired on the circle.\n       */\n      this.mouseDown = new EventEmitter();\n      /**\n       * This event is fired when the DOM mousemove event is fired on the circle.\n       */\n      this.mouseMove = new EventEmitter();\n      /**\n       * This event is fired on circle mouseout.\n       */\n      this.mouseOut = new EventEmitter();\n      /**\n       * This event is fired on circle mouseover.\n       */\n      this.mouseOver = new EventEmitter();\n      /**\n       * This event is fired when the DOM mouseup event is fired on the circle.\n       */\n      this.mouseUp = new EventEmitter();\n      /**\n       * This event is fired when the circle's radius is changed.\n       */\n      this.radiusChange = new EventEmitter();\n      /**\n       * This event is fired when the circle is right-clicked on.\n       */\n      this.rightClick = new EventEmitter();\n      this._circleAddedToManager = false;\n      this._eventSubscriptions = [];\n    }\n    /** @internal */\n    ngOnInit() {\n      this._manager.addCircle(this);\n      this._circleAddedToManager = true;\n      this._registerEventListeners();\n    }\n    /** @internal */\n    ngOnChanges(changes) {\n      if (!this._circleAddedToManager) {\n        return;\n      }\n      // tslint:disable: no-string-literal\n      if (changes['latitude'] || changes['longitude']) {\n        this._manager.setCenter(this);\n      }\n      if (changes['editable']) {\n        this._manager.setEditable(this);\n      }\n      if (changes['draggable']) {\n        this._manager.setDraggable(this);\n      }\n      if (changes['visible']) {\n        this._manager.setVisible(this);\n      }\n      if (changes['radius']) {\n        this._manager.setRadius(this);\n      }\n      // tslint:enable: no-string-literal\n      this._updateCircleOptionsChanges(changes);\n    }\n    _updateCircleOptionsChanges(changes) {\n      const options = {};\n      const optionKeys = Object.keys(changes).filter(k => AgmCircle._mapOptions.indexOf(k) !== -1);\n      optionKeys.forEach(k => {\n        options[k] = changes[k].currentValue;\n      });\n      if (optionKeys.length > 0) {\n        this._manager.setOptions(this, options);\n      }\n    }\n    _registerEventListeners() {\n      const events = new Map();\n      events.set('center_changed', this.centerChange);\n      events.set('click', this.circleClick);\n      events.set('dblclick', this.circleDblClick);\n      events.set('drag', this.drag);\n      events.set('dragend', this.dragEnd);\n      events.set('dragstart', this.dragStart);\n      events.set('mousedown', this.mouseDown);\n      events.set('mousemove', this.mouseMove);\n      events.set('mouseout', this.mouseOut);\n      events.set('mouseover', this.mouseOver);\n      events.set('mouseup', this.mouseUp);\n      events.set('radius_changed', this.radiusChange);\n      events.set('rightclick', this.rightClick);\n      events.forEach((eventEmitter, eventName) => {\n        this._eventSubscriptions.push(this._manager.createEventObservable(eventName, this).subscribe(value => {\n          switch (eventName) {\n            case 'radius_changed':\n              this._manager.getRadius(this).then(radius => eventEmitter.emit(radius));\n              break;\n            case 'center_changed':\n              this._manager.getCenter(this).then(center => eventEmitter.emit({\n                lat: center.lat(),\n                lng: center.lng()\n              }));\n              break;\n            default:\n              eventEmitter.emit(value);\n          }\n        }));\n      });\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._eventSubscriptions.forEach(s => s.unsubscribe());\n      this._eventSubscriptions = null;\n      this._manager.removeCircle(this);\n    }\n    /**\n     * Gets the LatLngBounds of this Circle.\n     */\n    getBounds() {\n      return this._manager.getBounds(this);\n    }\n    getCenter() {\n      return this._manager.getCenter(this);\n    }\n  }\n  AgmCircle.ɵfac = function AgmCircle_Factory(t) {\n    return new (t || AgmCircle)(ɵngcc0.ɵɵdirectiveInject(CircleManager));\n  };\n  AgmCircle.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmCircle,\n    selectors: [[\"agm-circle\"]],\n    inputs: {\n      clickable: \"clickable\",\n      draggable: [\"circleDraggable\", \"draggable\"],\n      editable: \"editable\",\n      radius: \"radius\",\n      strokePosition: \"strokePosition\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      latitude: \"latitude\",\n      longitude: \"longitude\",\n      fillColor: \"fillColor\",\n      fillOpacity: \"fillOpacity\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      zIndex: \"zIndex\"\n    },\n    outputs: {\n      centerChange: \"centerChange\",\n      circleClick: \"circleClick\",\n      circleDblClick: \"circleDblClick\",\n      drag: \"drag\",\n      dragEnd: \"dragEnd\",\n      dragStart: \"dragStart\",\n      mouseDown: \"mouseDown\",\n      mouseMove: \"mouseMove\",\n      mouseOut: \"mouseOut\",\n      mouseOver: \"mouseOver\",\n      mouseUp: \"mouseUp\",\n      radiusChange: \"radiusChange\",\n      rightClick: \"rightClick\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  AgmCircle._mapOptions = ['fillColor', 'fillOpacity', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'clickable'];\n  return AgmCircle;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet layerId$1 = 0;\n/**\n * AgmDataLayer enables the user to add data layers to the map.\n *\n * ### Example\n * ```typescript\n * import { Component } from 'angular2/core';\n * import { AgmMap, AgmDataLayer } from\n * 'angular-google-maps/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  directives: [AgmMap, AgmDataLayer],\n *  styles: [`\n *    .agm-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n * <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n * \t  <agm-data-layer [geoJson]=\"geoJsonObject\" (layerClick)=\"clicked($event)\" [style]=\"styleFunc\">\n * \t  </agm-data-layer>\n * </agm-map>\n *  `\n * })\n * export class MyMapCmp {\n *   lat: number = -25.274449;\n *   lng: number = 133.775060;\n *   zoom: number = 5;\n *\n * clicked(clickEvent) {\n *    console.log(clickEvent);\n *  }\n *\n *  styleFunc(feature) {\n *    return ({\n *      clickable: false,\n *      fillColor: feature.getProperty('color'),\n *      strokeWeight: 1\n *    });\n *  }\n *\n *  geoJsonObject: Object = {\n *    \"type\": \"FeatureCollection\",\n *    \"features\": [\n *      {\n *        \"type\": \"Feature\",\n *        \"properties\": {\n *          \"letter\": \"G\",\n *          \"color\": \"blue\",\n *          \"rank\": \"7\",\n *          \"ascii\": \"71\"\n *        },\n *        \"geometry\": {\n *          \"type\": \"Polygon\",\n *          \"coordinates\": [\n *            [\n *              [123.61, -22.14], [122.38, -21.73], [121.06, -21.69], [119.66, -22.22], [119.00, -23.40],\n *              [118.65, -24.76], [118.43, -26.07], [118.78, -27.56], [119.22, -28.57], [120.23, -29.49],\n *              [121.77, -29.87], [123.57, -29.64], [124.45, -29.03], [124.71, -27.95], [124.80, -26.70],\n *              [124.80, -25.60], [123.61, -25.64], [122.56, -25.64], [121.72, -25.72], [121.81, -26.62],\n *              [121.86, -26.98], [122.60, -26.90], [123.57, -27.05], [123.57, -27.68], [123.35, -28.18],\n *              [122.51, -28.38], [121.77, -28.26], [121.02, -27.91], [120.49, -27.21], [120.14, -26.50],\n *              [120.10, -25.64], [120.27, -24.52], [120.67, -23.68], [121.72, -23.32], [122.43, -23.48],\n *              [123.04, -24.04], [124.54, -24.28], [124.58, -23.20], [123.61, -22.14]\n *            ]\n *          ]\n *        }\n *      },\n *      {\n *        \"type\": \"Feature\",\n *        \"properties\": {\n *          \"letter\": \"o\",\n *          \"color\": \"red\",\n *          \"rank\": \"15\",\n *          \"ascii\": \"111\"\n *        },\n *        \"geometry\": {\n *          \"type\": \"Polygon\",\n *          \"coordinates\": [\n *            [\n *              [128.84, -25.76], [128.18, -25.60], [127.96, -25.52], [127.88, -25.52], [127.70, -25.60],\n *              [127.26, -25.79], [126.60, -26.11], [126.16, -26.78], [126.12, -27.68], [126.21, -28.42],\n *              [126.69, -29.49], [127.74, -29.80], [128.80, -29.72], [129.41, -29.03], [129.72, -27.95],\n *              [129.68, -27.21], [129.33, -26.23], [128.84, -25.76]\n *            ],\n *            [\n *              [128.45, -27.44], [128.32, -26.94], [127.70, -26.82], [127.35, -27.05], [127.17, -27.80],\n *              [127.57, -28.22], [128.10, -28.42], [128.49, -27.80], [128.45, -27.44]\n *            ]\n *          ]\n *        }\n *      },\n *      {\n *        \"type\": \"Feature\",\n *        \"properties\": {\n *          \"letter\": \"o\",\n *          \"color\": \"yellow\",\n *          \"rank\": \"15\",\n *          \"ascii\": \"111\"\n *        },\n *        \"geometry\": {\n *          \"type\": \"Polygon\",\n *          \"coordinates\": [\n *            [\n *              [131.87, -25.76], [131.35, -26.07], [130.95, -26.78], [130.82, -27.64], [130.86, -28.53],\n *              [131.26, -29.22], [131.92, -29.76], [132.45, -29.87], [133.06, -29.76], [133.72, -29.34],\n *              [134.07, -28.80], [134.20, -27.91], [134.07, -27.21], [133.81, -26.31], [133.37, -25.83],\n *              [132.71, -25.64], [131.87, -25.76]\n *            ],\n *            [\n *              [133.15, -27.17], [132.71, -26.86], [132.09, -26.90], [131.74, -27.56], [131.79, -28.26],\n *              [132.36, -28.45], [132.93, -28.34], [133.15, -27.76], [133.15, -27.17]\n *            ]\n *          ]\n *        }\n *      },\n *      {\n *        \"type\": \"Feature\",\n *        \"properties\": {\n *          \"letter\": \"g\",\n *          \"color\": \"blue\",\n *          \"rank\": \"7\",\n *          \"ascii\": \"103\"\n *        },\n *        \"geometry\": {\n *          \"type\": \"Polygon\",\n *          \"coordinates\": [\n *            [\n *              [138.12, -25.04], [136.84, -25.16], [135.96, -25.36], [135.26, -25.99], [135, -26.90],\n *              [135.04, -27.91], [135.26, -28.88], [136.05, -29.45], [137.02, -29.49], [137.81, -29.49],\n *              [137.94, -29.99], [137.90, -31.20], [137.85, -32.24], [136.88, -32.69], [136.45, -32.36],\n *              [136.27, -31.80], [134.95, -31.84], [135.17, -32.99], [135.52, -33.43], [136.14, -33.76],\n *              [137.06, -33.83], [138.12, -33.65], [138.86, -33.21], [139.30, -32.28], [139.30, -31.24],\n *              [139.30, -30.14], [139.21, -28.96], [139.17, -28.22], [139.08, -27.41], [139.08, -26.47],\n *              [138.99, -25.40], [138.73, -25.00], [138.12, -25.04]\n *            ],\n *            [\n *              [137.50, -26.54], [136.97, -26.47], [136.49, -26.58], [136.31, -27.13], [136.31, -27.72],\n *              [136.58, -27.99], [137.50, -28.03], [137.68, -27.68], [137.59, -26.78], [137.50, -26.54]\n *            ]\n *          ]\n *        }\n *      },\n *      {\n *        \"type\": \"Feature\",\n *        \"properties\": {\n *          \"letter\": \"l\",\n *          \"color\": \"green\",\n *          \"rank\": \"12\",\n *          \"ascii\": \"108\"\n *        },\n *        \"geometry\": {\n *          \"type\": \"Polygon\",\n *          \"coordinates\": [\n *            [\n *              [140.14, -21.04], [140.31, -29.42], [141.67, -29.49], [141.59, -20.92], [140.14, -21.04]\n *            ]\n *          ]\n *        }\n *      },\n *      {\n *        \"type\": \"Feature\",\n *        \"properties\": {\n *          \"letter\": \"e\",\n *          \"color\": \"red\",\n *          \"rank\": \"5\",\n *          \"ascii\": \"101\"\n *        },\n *        \"geometry\": {\n *          \"type\": \"Polygon\",\n *          \"coordinates\": [\n *            [\n *              [144.14, -27.41], [145.67, -27.52], [146.86, -27.09], [146.82, -25.64], [146.25, -25.04],\n *              [145.45, -24.68], [144.66, -24.60], [144.09, -24.76], [143.43, -25.08], [142.99, -25.40],\n *              [142.64, -26.03], [142.64, -27.05], [142.64, -28.26], [143.30, -29.11], [144.18, -29.57],\n *              [145.41, -29.64], [146.46, -29.19], [146.64, -28.72], [146.82, -28.14], [144.84, -28.42],\n *              [144.31, -28.26], [144.14, -27.41]\n *            ],\n *            [\n *              [144.18, -26.39], [144.53, -26.58], [145.19, -26.62], [145.72, -26.35], [145.81, -25.91],\n *              [145.41, -25.68], [144.97, -25.68], [144.49, -25.64], [144, -25.99], [144.18, -26.39]\n *            ]\n *          ]\n *        }\n *      }\n *    ]\n *  };\n * }\n * ```\n */\nlet AgmDataLayer = /*#__PURE__*/(() => {\n  class AgmDataLayer {\n    constructor(_manager) {\n      this._manager = _manager;\n      this._addedToManager = false;\n      this._id = (layerId$1++).toString();\n      this._subscriptions = [];\n      /**\n       * This event is fired when a feature in the layer is clicked.\n       */\n      this.layerClick = new EventEmitter();\n      /**\n       * The geoJson to be displayed\n       */\n      this.geoJson = null;\n    }\n    ngOnInit() {\n      if (this._addedToManager) {\n        return;\n      }\n      this._manager.addDataLayer(this);\n      this._addedToManager = true;\n      this._addEventListeners();\n    }\n    _addEventListeners() {\n      const listeners = [{\n        name: 'click',\n        handler: ev => this.layerClick.emit(ev)\n      }];\n      listeners.forEach(obj => {\n        const os = this._manager.createEventObservable(obj.name, this).subscribe(obj.handler);\n        this._subscriptions.push(os);\n      });\n    }\n    /** @internal */\n    id() {\n      return this._id;\n    }\n    /** @internal */\n    toString() {\n      return `AgmDataLayer-${this._id.toString()}`;\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._manager.deleteDataLayer(this);\n      // unsubscribe all registered observable subscriptions\n      this._subscriptions.forEach(s => s.unsubscribe());\n    }\n    /** @internal */\n    ngOnChanges(changes) {\n      if (!this._addedToManager) {\n        return;\n      }\n      // tslint:disable-next-line: no-string-literal\n      const geoJsonChange = changes['geoJson'];\n      if (geoJsonChange) {\n        this._manager.updateGeoJson(this, geoJsonChange.currentValue);\n      }\n      const dataOptions = AgmDataLayer._dataOptionsAttributes.reduce((options, k) => options[k] = changes.hasOwnProperty(k) ? changes[k].currentValue : this[k], {});\n      this._manager.setDataOptions(this, dataOptions);\n    }\n  }\n  AgmDataLayer.ɵfac = function AgmDataLayer_Factory(t) {\n    return new (t || AgmDataLayer)(ɵngcc0.ɵɵdirectiveInject(DataLayerManager));\n  };\n  AgmDataLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmDataLayer,\n    selectors: [[\"agm-data-layer\"]],\n    inputs: {\n      geoJson: \"geoJson\",\n      style: \"style\"\n    },\n    outputs: {\n      layerClick: \"layerClick\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  AgmDataLayer._dataOptionsAttributes = ['style'];\n  return AgmDataLayer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Adds the given directive to the auto fit bounds feature when the value is true.\n * To make it work with you custom AGM component, you also have to implement the {@link FitBoundsAccessor} abstract class.\n * @example\n * <agm-marker [agmFitBounds]=\"true\"></agm-marker>\n */\nlet AgmFitBounds = /*#__PURE__*/(() => {\n  class AgmFitBounds {\n    constructor(_fitBoundsAccessor, _fitBoundsService) {\n      this._fitBoundsAccessor = _fitBoundsAccessor;\n      this._fitBoundsService = _fitBoundsService;\n      /**\n       * If the value is true, the element gets added to the bounds of the map.\n       * Default: true.\n       */\n      this.agmFitBounds = true;\n      this._destroyed$ = new Subject();\n      this._latestFitBoundsDetails = null;\n    }\n    /**\n     * @internal\n     */\n    ngOnChanges() {\n      this._updateBounds();\n    }\n    /**\n     * @internal\n     */\n    ngOnInit() {\n      this._fitBoundsAccessor.getFitBoundsDetails$().pipe(distinctUntilChanged((x, y) => x.latLng.lat === y.latLng.lat && x.latLng.lng === y.latLng.lng), takeUntil(this._destroyed$)).subscribe(details => this._updateBounds(details));\n    }\n    /*\n     Either the location changed, or visible status changed.\n     Possible state changes are\n     invisible -> visible\n     visible -> invisible\n     visible -> visible (new location)\n    */\n    _updateBounds(newFitBoundsDetails) {\n      // either visibility will change, or location, so remove the old one anyway\n      if (this._latestFitBoundsDetails) {\n        this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);\n        // don't set latestFitBoundsDetails to null, because we can toggle visibility from\n        // true -> false -> true, in which case we still need old value cached here\n      }\n\n      if (newFitBoundsDetails) {\n        this._latestFitBoundsDetails = newFitBoundsDetails;\n      }\n      if (!this._latestFitBoundsDetails) {\n        return;\n      }\n      if (this.agmFitBounds === true) {\n        this._fitBoundsService.addToBounds(this._latestFitBoundsDetails.latLng);\n      }\n    }\n    /**\n     * @internal\n     */\n    ngOnDestroy() {\n      this._destroyed$.next();\n      this._destroyed$.complete();\n      if (this._latestFitBoundsDetails !== null) {\n        this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);\n      }\n    }\n  }\n  AgmFitBounds.ɵfac = function AgmFitBounds_Factory(t) {\n    return new (t || AgmFitBounds)(ɵngcc0.ɵɵdirectiveInject(FitBoundsAccessor, 2), ɵngcc0.ɵɵdirectiveInject(FitBoundsService));\n  };\n  AgmFitBounds.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmFitBounds,\n    selectors: [[\"\", \"agmFitBounds\", \"\"]],\n    inputs: {\n      agmFitBounds: \"agmFitBounds\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return AgmFitBounds;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet infoWindowId = 0;\n/**\n * AgmInfoWindow renders a info window inside a {@link AgmMarker} or standalone.\n *\n * ### Example\n * ```typescript\n * import { Component } from '@angular/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  styles: [`\n *    .agm-map-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <agm-marker [latitude]=\"lat\" [longitude]=\"lng\" [label]=\"'M'\">\n *        <agm-info-window [disableAutoPan]=\"true\">\n *          Hi, this is the content of the <strong>info window</strong>\n *        </agm-info-window>\n *      </agm-marker>\n *    </agm-map>\n *  `\n * })\n * ```\n */\nlet AgmInfoWindow = /*#__PURE__*/(() => {\n  class AgmInfoWindow {\n    constructor(_infoWindowManager, _el) {\n      this._infoWindowManager = _infoWindowManager;\n      this._el = _el;\n      /**\n       * Sets the open state for the InfoWindow. You can also call the open() and close() methods.\n       */\n      this.isOpen = false;\n      /**\n       * Emits an event when the info window is closed.\n       */\n      this.infoWindowClose = new EventEmitter();\n      this._infoWindowAddedToManager = false;\n      this._id = (infoWindowId++).toString();\n    }\n    ngOnInit() {\n      this.content = this._el.nativeElement.querySelector('.agm-info-window-content');\n      this._infoWindowManager.addInfoWindow(this);\n      this._infoWindowAddedToManager = true;\n      this._updateOpenState();\n      this._registerEventListeners();\n    }\n    /** @internal */\n    ngOnChanges(changes) {\n      if (!this._infoWindowAddedToManager) {\n        return;\n      }\n      // tslint:disable: no-string-literal\n      if ((changes['latitude'] || changes['longitude']) && typeof this.latitude === 'number' && typeof this.longitude === 'number') {\n        this._infoWindowManager.setPosition(this);\n      }\n      if (changes['zIndex']) {\n        this._infoWindowManager.setZIndex(this);\n      }\n      if (changes['isOpen']) {\n        this._updateOpenState();\n      }\n      this._setInfoWindowOptions(changes);\n    }\n    // tslint:enable: no-string-literal\n    _registerEventListeners() {\n      this._infoWindowManager.createEventObservable('closeclick', this).subscribe(() => {\n        this.isOpen = false;\n        this.infoWindowClose.emit();\n      });\n    }\n    _updateOpenState() {\n      this.isOpen ? this.open() : this.close();\n    }\n    _setInfoWindowOptions(changes) {\n      const options = {};\n      const optionKeys = Object.keys(changes).filter(k => AgmInfoWindow._infoWindowOptionsInputs.indexOf(k) !== -1);\n      optionKeys.forEach(k => {\n        options[k] = changes[k].currentValue;\n      });\n      this._infoWindowManager.setOptions(this, options);\n    }\n    /**\n     * Opens the info window.\n     */\n    open() {\n      return this._infoWindowManager.open(this);\n    }\n    /**\n     * Closes the info window.\n     */\n    close() {\n      return this._infoWindowManager.close(this).then(() => {\n        this.infoWindowClose.emit();\n      });\n    }\n    /** @internal */\n    id() {\n      return this._id;\n    }\n    /** @internal */\n    toString() {\n      return 'AgmInfoWindow-' + this._id.toString();\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._infoWindowManager.deleteInfoWindow(this);\n    }\n  }\n  AgmInfoWindow.ɵfac = function AgmInfoWindow_Factory(t) {\n    return new (t || AgmInfoWindow)(ɵngcc0.ɵɵdirectiveInject(InfoWindowManager), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  AgmInfoWindow.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: AgmInfoWindow,\n    selectors: [[\"agm-info-window\"]],\n    inputs: {\n      isOpen: \"isOpen\",\n      latitude: \"latitude\",\n      longitude: \"longitude\",\n      disableAutoPan: \"disableAutoPan\",\n      zIndex: \"zIndex\",\n      maxWidth: \"maxWidth\"\n    },\n    outputs: {\n      infoWindowClose: \"infoWindowClose\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"agm-info-window-content\"]],\n    template: function AgmInfoWindow_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  AgmInfoWindow._infoWindowOptionsInputs = ['disableAutoPan', 'maxWidth'];\n  return AgmInfoWindow;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet layerId$2 = 0;\nlet AgmKmlLayer = /*#__PURE__*/(() => {\n  class AgmKmlLayer {\n    constructor(_manager) {\n      this._manager = _manager;\n      this._addedToManager = false;\n      this._id = (layerId$2++).toString();\n      this._subscriptions = [];\n      /**\n       * If true, the layer receives mouse events. Default value is true.\n       */\n      this.clickable = true;\n      /**\n       * By default, the input map is centered and zoomed to the bounding box of the contents of the\n       * layer.\n       * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom\n       * were never set.\n       */\n      this.preserveViewport = false;\n      /**\n       * Whether to render the screen overlays. Default true.\n       */\n      this.screenOverlays = true;\n      /**\n       * Suppress the rendering of info windows when layer features are clicked.\n       */\n      this.suppressInfoWindows = false;\n      /**\n       * The URL of the KML document to display.\n       */\n      this.url = null;\n      /**\n       * The z-index of the layer.\n       */\n      this.zIndex = null;\n      /**\n       * This event is fired when a feature in the layer is clicked.\n       */\n      this.layerClick = new EventEmitter();\n      /**\n       * This event is fired when the KML layers default viewport has changed.\n       */\n      this.defaultViewportChange = new EventEmitter();\n      /**\n       * This event is fired when the KML layer has finished loading.\n       * At this point it is safe to read the status property to determine if the layer loaded\n       * successfully.\n       */\n      this.statusChange = new EventEmitter();\n    }\n    ngOnInit() {\n      if (this._addedToManager) {\n        return;\n      }\n      this._manager.addKmlLayer(this);\n      this._addedToManager = true;\n      this._addEventListeners();\n    }\n    ngOnChanges(changes) {\n      if (!this._addedToManager) {\n        return;\n      }\n      this._updatePolygonOptions(changes);\n    }\n    _updatePolygonOptions(changes) {\n      const options = Object.keys(changes).filter(k => AgmKmlLayer._kmlLayerOptions.indexOf(k) !== -1).reduce((obj, k) => {\n        obj[k] = changes[k].currentValue;\n        return obj;\n      }, {});\n      if (Object.keys(options).length > 0) {\n        this._manager.setOptions(this, options);\n      }\n    }\n    _addEventListeners() {\n      const listeners = [{\n        name: 'click',\n        handler: ev => this.layerClick.emit(ev)\n      }, {\n        name: 'defaultviewport_changed',\n        handler: () => this.defaultViewportChange.emit()\n      }, {\n        name: 'status_changed',\n        handler: () => this.statusChange.emit()\n      }];\n      listeners.forEach(obj => {\n        const os = this._manager.createEventObservable(obj.name, this).subscribe(obj.handler);\n        this._subscriptions.push(os);\n      });\n    }\n    /** @internal */\n    id() {\n      return this._id;\n    }\n    /** @internal */\n    toString() {\n      return `AgmKmlLayer-${this._id.toString()}`;\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._manager.deleteKmlLayer(this);\n      // unsubscribe all registered observable subscriptions\n      this._subscriptions.forEach(s => s.unsubscribe());\n    }\n  }\n  AgmKmlLayer.ɵfac = function AgmKmlLayer_Factory(t) {\n    return new (t || AgmKmlLayer)(ɵngcc0.ɵɵdirectiveInject(KmlLayerManager));\n  };\n  AgmKmlLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmKmlLayer,\n    selectors: [[\"agm-kml-layer\"]],\n    inputs: {\n      clickable: \"clickable\",\n      preserveViewport: \"preserveViewport\",\n      screenOverlays: \"screenOverlays\",\n      suppressInfoWindows: \"suppressInfoWindows\",\n      url: \"url\",\n      zIndex: \"zIndex\"\n    },\n    outputs: {\n      layerClick: \"layerClick\",\n      defaultViewportChange: \"defaultViewportChange\",\n      statusChange: \"statusChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  AgmKmlLayer._kmlLayerOptions = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'];\n  return AgmKmlLayer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmMapControl = /*#__PURE__*/(() => {\n  class AgmMapControl {}\n  AgmMapControl.ɵfac = function AgmMapControl_Factory(t) {\n    return new (t || AgmMapControl)();\n  };\n  AgmMapControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmMapControl,\n    inputs: {\n      position: \"position\"\n    }\n  });\n  return AgmMapControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmFullscreenControl = /*#__PURE__*/(() => {\n  class AgmFullscreenControl extends AgmMapControl {\n    getOptions() {\n      return {\n        fullscreenControl: true,\n        fullscreenControlOptions: {\n          position: this.position && google.maps.ControlPosition[this.position]\n        }\n      };\n    }\n  }\n  AgmFullscreenControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAgmFullscreenControl_BaseFactory;\n    return function AgmFullscreenControl_Factory(t) {\n      return (ɵAgmFullscreenControl_BaseFactory || (ɵAgmFullscreenControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AgmFullscreenControl)))(t || AgmFullscreenControl);\n    };\n  }();\n  AgmFullscreenControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmFullscreenControl,\n    selectors: [[\"agm-fullscreen-control\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: AgmMapControl,\n      useExisting: AgmFullscreenControl\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return AgmFullscreenControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmMapTypeControl = /*#__PURE__*/(() => {\n  class AgmMapTypeControl extends AgmMapControl {\n    getOptions() {\n      return {\n        mapTypeControl: true,\n        mapTypeControlOptions: {\n          position: this.position && google.maps.ControlPosition[this.position],\n          style: this.style && google.maps.MapTypeControlStyle[this.style],\n          mapTypeIds: this.mapTypeIds && this.mapTypeIds.map(mapTypeId => google.maps.MapTypeId[mapTypeId])\n        }\n      };\n    }\n  }\n  AgmMapTypeControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAgmMapTypeControl_BaseFactory;\n    return function AgmMapTypeControl_Factory(t) {\n      return (ɵAgmMapTypeControl_BaseFactory || (ɵAgmMapTypeControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AgmMapTypeControl)))(t || AgmMapTypeControl);\n    };\n  }();\n  AgmMapTypeControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmMapTypeControl,\n    selectors: [[\"agm-map-type-control\"]],\n    inputs: {\n      mapTypeIds: \"mapTypeIds\",\n      style: \"style\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: AgmMapControl,\n      useExisting: AgmMapTypeControl\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return AgmMapTypeControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmPanControl = /*#__PURE__*/(() => {\n  class AgmPanControl extends AgmMapControl {\n    getOptions() {\n      return {\n        panControl: true,\n        panControlOptions: {\n          position: this.position && google.maps.ControlPosition[this.position]\n        }\n      };\n    }\n  }\n  AgmPanControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAgmPanControl_BaseFactory;\n    return function AgmPanControl_Factory(t) {\n      return (ɵAgmPanControl_BaseFactory || (ɵAgmPanControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AgmPanControl)))(t || AgmPanControl);\n    };\n  }();\n  AgmPanControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmPanControl,\n    selectors: [[\"agm-pan-control\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: AgmMapControl,\n      useExisting: AgmPanControl\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return AgmPanControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmRotateControl = /*#__PURE__*/(() => {\n  class AgmRotateControl extends AgmMapControl {\n    getOptions() {\n      return {\n        rotateControl: true,\n        rotateControlOptions: {\n          position: this.position && google.maps.ControlPosition[this.position]\n        }\n      };\n    }\n  }\n  AgmRotateControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAgmRotateControl_BaseFactory;\n    return function AgmRotateControl_Factory(t) {\n      return (ɵAgmRotateControl_BaseFactory || (ɵAgmRotateControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AgmRotateControl)))(t || AgmRotateControl);\n    };\n  }();\n  AgmRotateControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmRotateControl,\n    selectors: [[\"agm-rotate-control\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: AgmMapControl,\n      useExisting: AgmRotateControl\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return AgmRotateControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmScaleControl = /*#__PURE__*/(() => {\n  class AgmScaleControl extends AgmMapControl {\n    getOptions() {\n      return {\n        scaleControl: true\n      };\n    }\n  }\n  AgmScaleControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAgmScaleControl_BaseFactory;\n    return function AgmScaleControl_Factory(t) {\n      return (ɵAgmScaleControl_BaseFactory || (ɵAgmScaleControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AgmScaleControl)))(t || AgmScaleControl);\n    };\n  }();\n  AgmScaleControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmScaleControl,\n    selectors: [[\"agm-scale-control\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: AgmMapControl,\n      useExisting: AgmScaleControl\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return AgmScaleControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmStreetViewControl = /*#__PURE__*/(() => {\n  class AgmStreetViewControl extends AgmMapControl {\n    getOptions() {\n      return {\n        streetViewControl: true,\n        streetViewControlOptions: {\n          position: this.position && google.maps.ControlPosition[this.position]\n        }\n      };\n    }\n  }\n  AgmStreetViewControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAgmStreetViewControl_BaseFactory;\n    return function AgmStreetViewControl_Factory(t) {\n      return (ɵAgmStreetViewControl_BaseFactory || (ɵAgmStreetViewControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AgmStreetViewControl)))(t || AgmStreetViewControl);\n    };\n  }();\n  AgmStreetViewControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmStreetViewControl,\n    selectors: [[\"agm-street-view-control\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: AgmMapControl,\n      useExisting: AgmStreetViewControl\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return AgmStreetViewControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmZoomControl = /*#__PURE__*/(() => {\n  class AgmZoomControl extends AgmMapControl {\n    getOptions() {\n      return {\n        zoomControl: true,\n        zoomControlOptions: {\n          position: this.position && google.maps.ControlPosition[this.position],\n          style: this.style && google.maps.ZoomControlStyle[this.style]\n        }\n      };\n    }\n  }\n  AgmZoomControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAgmZoomControl_BaseFactory;\n    return function AgmZoomControl_Factory(t) {\n      return (ɵAgmZoomControl_BaseFactory || (ɵAgmZoomControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AgmZoomControl)))(t || AgmZoomControl);\n    };\n  }();\n  AgmZoomControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmZoomControl,\n    selectors: [[\"agm-zoom-control\"]],\n    inputs: {\n      style: \"style\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: AgmMapControl,\n      useExisting: AgmZoomControl\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return AgmZoomControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * AgmMap renders a Google Map.\n * **Important note**: To be able see a map in the browser, you have to define a height for the\n * element `agm-map`.\n *\n * ### Example\n * ```typescript\n * import { Component } from '@angular/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  styles: [`\n *    agm-map {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *    </agm-map>\n *  `\n * })\n * ```\n */\nlet AgmMap = /*#__PURE__*/(() => {\n  class AgmMap {\n    constructor(_elem, _mapsWrapper,\n    // tslint:disable-next-line: ban-types\n    _platformId, _fitBoundsService, _zone) {\n      this._elem = _elem;\n      this._mapsWrapper = _mapsWrapper;\n      this._platformId = _platformId;\n      this._fitBoundsService = _fitBoundsService;\n      this._zone = _zone;\n      /**\n       * The longitude that defines the center of the map.\n       */\n      this.longitude = 0;\n      /**\n       * The latitude that defines the center of the map.\n       */\n      this.latitude = 0;\n      /**\n       * The zoom level of the map. The default zoom level is 8.\n       */\n      this.zoom = 8;\n      /**\n       * Enables/disables if map is draggable.\n       */\n      // tslint:disable-next-line:no-input-rename\n      this.draggable = true;\n      /**\n       * Enables/disables zoom and center on double click. Enabled by default.\n       */\n      this.disableDoubleClickZoom = false;\n      /**\n       * Enables/disables all default UI of the Google map. Please note: When the map is created, this\n       * value cannot get updated.\n       */\n      this.disableDefaultUI = false;\n      /**\n       * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.\n       */\n      this.scrollwheel = true;\n      /**\n       * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are\n       * enabled by default.\n       */\n      this.keyboardShortcuts = true;\n      /**\n       * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain\n       * modes, these styles will only apply to labels and geometry.\n       */\n      this.styles = [];\n      /**\n       * When true and the latitude and/or longitude values changes, the Google Maps panTo method is\n       * used to\n       * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map\n       */\n      this.usePanning = false;\n      /**\n       * Sets the viewport to contain the given bounds.\n       * If this option to `true`, the bounds get automatically computed from all elements that use the {@link AgmFitBounds} directive.\n       */\n      this.fitBounds = false;\n      /**\n       * The map mapTypeId. Defaults to 'roadmap'.\n       */\n      this.mapTypeId = 'ROADMAP';\n      /**\n       * When false, map icons are not clickable. A map icon represents a point of interest,\n       * also known as a POI. By default map icons are clickable.\n       */\n      this.clickableIcons = true;\n      /**\n       * A map icon represents a point of interest, also known as a POI.\n       * When map icons are clickable by default, an info window is displayed.\n       * When this property is set to false, the info window will not be shown but the click event\n       * will still fire\n       */\n      this.showDefaultInfoWindow = true;\n      /**\n       * This setting controls how gestures on the map are handled.\n       * Allowed values:\n       * - 'cooperative' (Two-finger touch gestures pan and zoom the map. One-finger touch gestures are not handled by the map.)\n       * - 'greedy'      (All touch gestures pan or zoom the map.)\n       * - 'none'        (The map cannot be panned or zoomed by user gestures.)\n       * - 'auto'        [default] (Gesture handling is either cooperative or greedy, depending on whether the page is scrollable or not.\n       */\n      this.gestureHandling = 'auto';\n      /**\n       * Controls the automatic switching behavior for the angle of incidence of\n       * the map. The only allowed values are 0 and 45. The value 0 causes the map\n       * to always use a 0° overhead view regardless of the zoom level and\n       * viewport. The value 45 causes the tilt angle to automatically switch to\n       * 45 whenever 45° imagery is available for the current zoom level and\n       * viewport, and switch back to 0 whenever 45° imagery is not available\n       * (this is the default behavior). 45° imagery is only available for\n       * satellite and hybrid map types, within some locations, and at some zoom\n       * levels. Note: getTilt returns the current tilt angle, not the value\n       * specified by this option. Because getTilt and this option refer to\n       * different things, do not bind() the tilt property; doing so may yield\n       * unpredictable effects. (Default of AGM is 0 (disabled). Enable it with value 45.)\n       */\n      this.tilt = 0;\n      this._observableSubscriptions = [];\n      /**\n       * This event emitter gets emitted when the user clicks on the map (but not when they click on a\n       * marker or infoWindow).\n       */\n      // tslint:disable-next-line: max-line-length\n      this.mapClick = new EventEmitter();\n      /**\n       * This event emitter gets emitted when the user right-clicks on the map (but not when they click\n       * on a marker or infoWindow).\n       */\n      this.mapRightClick = new EventEmitter();\n      /**\n       * This event emitter gets emitted when the user double-clicks on the map (but not when they click\n       * on a marker or infoWindow).\n       */\n      this.mapDblClick = new EventEmitter();\n      /**\n       * This event emitter is fired when the map center changes.\n       */\n      this.centerChange = new EventEmitter();\n      /**\n       * This event is fired when the viewport bounds have changed.\n       */\n      this.boundsChange = new EventEmitter();\n      /**\n       * This event is fired when the mapTypeId property changes.\n       */\n      this.mapTypeIdChange = new EventEmitter();\n      /**\n       * This event is fired when the map becomes idle after panning or zooming.\n       */\n      this.idle = new EventEmitter();\n      /**\n       * This event is fired when the zoom level has changed.\n       */\n      this.zoomChange = new EventEmitter();\n      /**\n       * This event is fired when the google map is fully initialized.\n       * You get the google.maps.Map instance as a result of this EventEmitter.\n       */\n      this.mapReady = new EventEmitter();\n      /**\n       * This event is fired when the visible tiles have finished loading.\n       */\n      this.tilesLoaded = new EventEmitter();\n    }\n    /** @internal */\n    ngAfterContentInit() {\n      if (isPlatformServer(this._platformId)) {\n        // The code is running on the server, do nothing\n        return;\n      }\n      // todo: this should be solved with a new component and a viewChild decorator\n      const container = this._elem.nativeElement.querySelector('.agm-map-container-inner');\n      this._initMapInstance(container);\n    }\n    _initMapInstance(el) {\n      this._mapsWrapper.createMap(el, {\n        center: {\n          lat: this.latitude || 0,\n          lng: this.longitude || 0\n        },\n        zoom: this.zoom,\n        minZoom: this.minZoom,\n        maxZoom: this.maxZoom,\n        controlSize: this.controlSize,\n        disableDefaultUI: this.disableDefaultUI,\n        disableDoubleClickZoom: this.disableDoubleClickZoom,\n        scrollwheel: this.scrollwheel,\n        backgroundColor: this.backgroundColor,\n        draggable: this.draggable,\n        draggableCursor: this.draggableCursor,\n        draggingCursor: this.draggingCursor,\n        keyboardShortcuts: this.keyboardShortcuts,\n        styles: this.styles,\n        mapTypeId: this.mapTypeId.toLocaleLowerCase(),\n        clickableIcons: this.clickableIcons,\n        gestureHandling: this.gestureHandling,\n        tilt: this.tilt,\n        restriction: this.restriction\n      }).then(() => this._mapsWrapper.getNativeMap()).then(map => this.mapReady.emit(map));\n      // register event listeners\n      this._handleMapCenterChange();\n      this._handleMapZoomChange();\n      this._handleMapMouseEvents();\n      this._handleBoundsChange();\n      this._handleMapTypeIdChange();\n      this._handleTilesLoadedEvent();\n      this._handleIdleEvent();\n      this._handleControlChange();\n    }\n    /** @internal */\n    ngOnDestroy() {\n      // unsubscribe all registered observable subscriptions\n      this._observableSubscriptions.forEach(s => s.unsubscribe());\n      // remove all listeners from the map instance\n      this._mapsWrapper.clearInstanceListeners();\n      if (this._fitBoundsSubscription) {\n        this._fitBoundsSubscription.unsubscribe();\n      }\n    }\n    /* @internal */\n    ngOnChanges(changes) {\n      this._updateMapOptionsChanges(changes);\n      this._updatePosition(changes);\n    }\n    _updateMapOptionsChanges(changes) {\n      const options = {};\n      const optionKeys = Object.keys(changes).filter(k => AgmMap._mapOptionsAttributes.indexOf(k) !== -1);\n      optionKeys.forEach(k => {\n        options[k] = changes[k].currentValue;\n      });\n      this._mapsWrapper.setMapOptions(options);\n    }\n    /**\n     * Triggers a resize event on the google map instance.\n     * When recenter is true, the of the google map gets called with the current lat/lng values or fitBounds value to recenter the map.\n     * Returns a promise that gets resolved after the event was triggered.\n     */\n    triggerResize(recenter = true) {\n      // Note: When we would trigger the resize event and show the map in the same turn (which is a\n      // common case for triggering a resize event), then the resize event would not\n      // work (to show the map), so we trigger the event in a timeout.\n      return new Promise(resolve => {\n        setTimeout(() => {\n          return this._mapsWrapper.triggerMapEvent('resize').then(() => {\n            if (recenter) {\n              this.fitBounds != null ? this._fitBounds() : this._setCenter();\n            }\n            resolve();\n          });\n        });\n      });\n    }\n    _updatePosition(changes) {\n      // tslint:disable: no-string-literal\n      if (changes['latitude'] == null && changes['longitude'] == null && !changes['fitBounds']) {\n        // no position update needed\n        return;\n      }\n      // tslint:enable: no-string-literal\n      // we prefer fitBounds in changes\n      if ('fitBounds' in changes) {\n        this._fitBounds();\n        return;\n      }\n      if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {\n        return;\n      }\n      this._setCenter();\n    }\n    _setCenter() {\n      const newCenter = {\n        lat: this.latitude,\n        lng: this.longitude\n      };\n      if (this.usePanning) {\n        this._mapsWrapper.panTo(newCenter);\n      } else {\n        this._mapsWrapper.setCenter(newCenter);\n      }\n    }\n    _fitBounds() {\n      switch (this.fitBounds) {\n        case true:\n          this._subscribeToFitBoundsUpdates();\n          break;\n        case false:\n          if (this._fitBoundsSubscription) {\n            this._fitBoundsSubscription.unsubscribe();\n          }\n          break;\n        default:\n          if (this._fitBoundsSubscription) {\n            this._fitBoundsSubscription.unsubscribe();\n          }\n          this._updateBounds(this.fitBounds, this.fitBoundsPadding);\n      }\n    }\n    _subscribeToFitBoundsUpdates() {\n      this._zone.runOutsideAngular(() => {\n        this._fitBoundsSubscription = this._fitBoundsService.getBounds$().subscribe(b => {\n          this._zone.run(() => this._updateBounds(b, this.fitBoundsPadding));\n        });\n      });\n    }\n    _updateBounds(bounds, padding) {\n      if (!bounds) {\n        return;\n      }\n      if (this._isLatLngBoundsLiteral(bounds) && typeof google !== 'undefined' && google && google.maps && google.maps.LatLngBounds) {\n        const newBounds = new google.maps.LatLngBounds();\n        newBounds.union(bounds);\n        bounds = newBounds;\n      }\n      if (this.usePanning) {\n        this._mapsWrapper.panToBounds(bounds, padding);\n        return;\n      }\n      this._mapsWrapper.fitBounds(bounds, padding);\n    }\n    _isLatLngBoundsLiteral(bounds) {\n      return bounds != null && bounds.extend === undefined;\n    }\n    _handleMapCenterChange() {\n      const s = this._mapsWrapper.subscribeToMapEvent('center_changed').subscribe(() => {\n        this._mapsWrapper.getCenter().then(center => {\n          this.latitude = center.lat();\n          this.longitude = center.lng();\n          this.centerChange.emit({\n            lat: this.latitude,\n            lng: this.longitude\n          });\n        });\n      });\n      this._observableSubscriptions.push(s);\n    }\n    _handleBoundsChange() {\n      const s = this._mapsWrapper.subscribeToMapEvent('bounds_changed').subscribe(() => {\n        this._mapsWrapper.getBounds().then(bounds => {\n          this.boundsChange.emit(bounds);\n        });\n      });\n      this._observableSubscriptions.push(s);\n    }\n    _handleMapTypeIdChange() {\n      const s = this._mapsWrapper.subscribeToMapEvent('maptypeid_changed').subscribe(() => {\n        this._mapsWrapper.getMapTypeId().then(mapTypeId => {\n          this.mapTypeIdChange.emit(mapTypeId);\n        });\n      });\n      this._observableSubscriptions.push(s);\n    }\n    _handleMapZoomChange() {\n      const s = this._mapsWrapper.subscribeToMapEvent('zoom_changed').subscribe(() => {\n        this._mapsWrapper.getZoom().then(z => {\n          this.zoom = z;\n          this.zoomChange.emit(z);\n        });\n      });\n      this._observableSubscriptions.push(s);\n    }\n    _handleIdleEvent() {\n      const s = this._mapsWrapper.subscribeToMapEvent('idle').subscribe(() => {\n        this.idle.emit(void 0);\n      });\n      this._observableSubscriptions.push(s);\n    }\n    _handleTilesLoadedEvent() {\n      const s = this._mapsWrapper.subscribeToMapEvent('tilesloaded').subscribe(() => this.tilesLoaded.emit(void 0));\n      this._observableSubscriptions.push(s);\n    }\n    _handleMapMouseEvents() {\n      const events = [{\n        name: 'click',\n        emitter: this.mapClick\n      }, {\n        name: 'rightclick',\n        emitter: this.mapRightClick\n      }, {\n        name: 'dblclick',\n        emitter: this.mapDblClick\n      }];\n      events.forEach(e => {\n        const s = this._mapsWrapper.subscribeToMapEvent(e.name).subscribe(([event]) => {\n          // the placeId will be undefined in case the event was not an IconMouseEvent (google types)\n          if (event.placeId && !this.showDefaultInfoWindow) {\n            event.stop();\n          }\n          e.emitter.emit(event);\n        });\n        this._observableSubscriptions.push(s);\n      });\n    }\n    _handleControlChange() {\n      this._setControls();\n      this.mapControls.changes.subscribe(() => this._setControls());\n    }\n    _setControls() {\n      const controlOptions = {\n        fullscreenControl: !this.disableDefaultUI,\n        mapTypeControl: false,\n        panControl: false,\n        rotateControl: false,\n        scaleControl: false,\n        streetViewControl: !this.disableDefaultUI,\n        zoomControl: !this.disableDefaultUI\n      };\n      this._mapsWrapper.getNativeMap().then(() => {\n        this.mapControls.forEach(control => Object.assign(controlOptions, control.getOptions()));\n        this._mapsWrapper.setMapOptions(controlOptions);\n      });\n    }\n  }\n  AgmMap.ɵfac = function AgmMap_Factory(t) {\n    return new (t || AgmMap)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(FitBoundsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n  AgmMap.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: AgmMap,\n    selectors: [[\"agm-map\"]],\n    contentQueries: function AgmMap_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, AgmMapControl, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.mapControls = _t);\n      }\n    },\n    inputs: {\n      longitude: \"longitude\",\n      latitude: \"latitude\",\n      zoom: \"zoom\",\n      draggable: [\"mapDraggable\", \"draggable\"],\n      disableDoubleClickZoom: \"disableDoubleClickZoom\",\n      disableDefaultUI: \"disableDefaultUI\",\n      scrollwheel: \"scrollwheel\",\n      keyboardShortcuts: \"keyboardShortcuts\",\n      styles: \"styles\",\n      usePanning: \"usePanning\",\n      fitBounds: \"fitBounds\",\n      mapTypeId: \"mapTypeId\",\n      clickableIcons: \"clickableIcons\",\n      showDefaultInfoWindow: \"showDefaultInfoWindow\",\n      gestureHandling: \"gestureHandling\",\n      tilt: \"tilt\",\n      minZoom: \"minZoom\",\n      maxZoom: \"maxZoom\",\n      controlSize: \"controlSize\",\n      backgroundColor: \"backgroundColor\",\n      draggableCursor: \"draggableCursor\",\n      draggingCursor: \"draggingCursor\",\n      fitBoundsPadding: \"fitBoundsPadding\",\n      restriction: \"restriction\"\n    },\n    outputs: {\n      mapClick: \"mapClick\",\n      mapRightClick: \"mapRightClick\",\n      mapDblClick: \"mapDblClick\",\n      centerChange: \"centerChange\",\n      boundsChange: \"boundsChange\",\n      mapTypeIdChange: \"mapTypeIdChange\",\n      idle: \"idle\",\n      zoomChange: \"zoomChange\",\n      mapReady: \"mapReady\",\n      tilesLoaded: \"tilesLoaded\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([CircleManager, DataLayerManager, DataLayerManager, FitBoundsService, GoogleMapsAPIWrapper, InfoWindowManager, KmlLayerManager, LayerManager, MarkerManager, PolygonManager, PolylineManager, RectangleManager]), ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 0,\n    consts: [[1, \"agm-map-container-inner\", \"sebm-google-map-container-inner\"], [1, \"agm-map-content\"]],\n    template: function AgmMap_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    styles: [\".agm-map-container-inner[_ngcontent-%COMP%] {\\n      width: inherit;\\n      height: inherit;\\n    }\\n    .agm-map-content[_ngcontent-%COMP%] {\\n      display:none;\\n    }\"]\n  });\n  /**\n   * Map option attributes that can change over time\n   */\n  AgmMap._mapOptionsAttributes = ['disableDoubleClickZoom', 'scrollwheel', 'draggable', 'draggableCursor', 'draggingCursor', 'keyboardShortcuts', 'styles', 'zoom', 'minZoom', 'maxZoom', 'mapTypeId', 'clickableIcons', 'gestureHandling', 'tilt', 'restriction'];\n  return AgmMap;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet markerId = 0;\n/**\n * AgmMarker renders a map marker inside a {@link AgmMap}.\n *\n * ### Example\n * ```typescript\n * import { Component } from '@angular/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  styles: [`\n *    .agm-map-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <agm-marker [latitude]=\"lat\" [longitude]=\"lng\" [label]=\"'M'\">\n *      </agm-marker>\n *    </agm-map>\n *  `\n * })\n * ```\n */\nlet AgmMarker = /*#__PURE__*/(() => {\n  class AgmMarker {\n    constructor(_markerManager) {\n      this._markerManager = _markerManager;\n      /**\n       * If true, the marker can be dragged. Default value is false.\n       */\n      // tslint:disable-next-line:no-input-rename\n      this.draggable = false;\n      /**\n       * If true, the marker is visible\n       */\n      this.visible = true;\n      /**\n       * Whether to automatically open the child info window when the marker is clicked.\n       */\n      this.openInfoWindow = true;\n      /**\n       * The marker's opacity between 0.0 and 1.0.\n       */\n      this.opacity = 1;\n      /**\n       * All markers are displayed on the map in order of their zIndex, with higher values displaying in\n       * front of markers with lower values. By default, markers are displayed according to their\n       * vertical position on screen, with lower markers appearing in front of markers further up the\n       * screen.\n       */\n      this.zIndex = 1;\n      /**\n       * If true, the marker can be clicked. Default value is true.\n       */\n      // tslint:disable-next-line:no-input-rename\n      this.clickable = true;\n      /**\n       * This event is fired when the marker's animation property changes.\n       */\n      this.animationChange = new EventEmitter();\n      /**\n       * This event emitter gets emitted when the user clicks on the marker.\n       */\n      this.markerClick = new EventEmitter();\n      /**\n       * This event emitter gets emitted when the user clicks twice on the marker.\n       */\n      this.markerDblClick = new EventEmitter();\n      /**\n       * This event is fired when the user rightclicks on the marker.\n       */\n      this.markerRightClick = new EventEmitter();\n      /**\n       * This event is fired when the user starts dragging the marker.\n       */\n      this.dragStart = new EventEmitter();\n      /**\n       * This event is repeatedly fired while the user drags the marker.\n       */\n      // tslint:disable-next-line: no-output-native\n      this.drag = new EventEmitter();\n      /**\n       * This event is fired when the user stops dragging the marker.\n       */\n      this.dragEnd = new EventEmitter();\n      /**\n       * This event is fired when the user mouses over the marker.\n       */\n      this.mouseOver = new EventEmitter();\n      /**\n       * This event is fired when the user mouses outside the marker.\n       */\n      this.mouseOut = new EventEmitter();\n      /** @internal */\n      this.infoWindow = new QueryList();\n      this._markerAddedToManger = false;\n      this._observableSubscriptions = [];\n      this._fitBoundsDetails$ = new ReplaySubject(1);\n      this._id = (markerId++).toString();\n    }\n    /* @internal */\n    ngAfterContentInit() {\n      this.handleInfoWindowUpdate();\n      this.infoWindow.changes.subscribe(() => this.handleInfoWindowUpdate());\n    }\n    handleInfoWindowUpdate() {\n      if (this.infoWindow.length > 1) {\n        throw new Error('Expected no more than one info window.');\n      }\n      this.infoWindow.forEach(marker => {\n        marker.hostMarker = this;\n      });\n    }\n    /** @internal */\n    ngOnChanges(changes) {\n      if (typeof this.latitude === 'string') {\n        this.latitude = Number(this.latitude);\n      }\n      if (typeof this.longitude === 'string') {\n        this.longitude = Number(this.longitude);\n      }\n      if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {\n        return;\n      }\n      if (!this._markerAddedToManger) {\n        this._markerManager.addMarker(this);\n        this._updateFitBoundsDetails();\n        this._markerAddedToManger = true;\n        this._addEventListeners();\n        return;\n      }\n      // tslint:disable: no-string-literal\n      if (changes['latitude'] || changes['longitude']) {\n        this._markerManager.updateMarkerPosition(this);\n        this._updateFitBoundsDetails();\n      }\n      if (changes['title']) {\n        this._markerManager.updateTitle(this);\n      }\n      if (changes['label']) {\n        this._markerManager.updateLabel(this);\n      }\n      if (changes['draggable']) {\n        this._markerManager.updateDraggable(this);\n      }\n      if (changes['iconUrl']) {\n        this._markerManager.updateIcon(this);\n      }\n      if (changes['opacity']) {\n        this._markerManager.updateOpacity(this);\n      }\n      if (changes['visible']) {\n        this._markerManager.updateVisible(this);\n      }\n      if (changes['zIndex']) {\n        this._markerManager.updateZIndex(this);\n      }\n      if (changes['clickable']) {\n        this._markerManager.updateClickable(this);\n      }\n      if (changes['animation']) {\n        this._markerManager.updateAnimation(this);\n      }\n      // tslint:enable: no-string-literal\n    }\n    /** @internal */\n    getFitBoundsDetails$() {\n      return this._fitBoundsDetails$.asObservable();\n    }\n    _updateFitBoundsDetails() {\n      this._fitBoundsDetails$.next({\n        latLng: {\n          lat: this.latitude,\n          lng: this.longitude\n        }\n      });\n    }\n    _addEventListeners() {\n      const cs = this._markerManager.createEventObservable('click', this).subscribe(() => {\n        if (this.openInfoWindow) {\n          this.infoWindow.forEach(infoWindow => infoWindow.open());\n        }\n        this.markerClick.emit(this);\n      });\n      this._observableSubscriptions.push(cs);\n      const dcs = this._markerManager.createEventObservable('dblclick', this).subscribe(() => {\n        this.markerDblClick.emit(null);\n      });\n      this._observableSubscriptions.push(dcs);\n      const rc = this._markerManager.createEventObservable('rightclick', this).subscribe(() => {\n        this.markerRightClick.emit(null);\n      });\n      this._observableSubscriptions.push(rc);\n      const ds = this._markerManager.createEventObservable('dragstart', this).subscribe(e => this.dragStart.emit(e));\n      this._observableSubscriptions.push(ds);\n      const d = this._markerManager.createEventObservable('drag', this).subscribe(e => this.drag.emit(e));\n      this._observableSubscriptions.push(d);\n      const de = this._markerManager.createEventObservable('dragend', this).subscribe(e => this.dragEnd.emit(e));\n      this._observableSubscriptions.push(de);\n      const mover = this._markerManager.createEventObservable('mouseover', this).subscribe(e => this.mouseOver.emit(e));\n      this._observableSubscriptions.push(mover);\n      const mout = this._markerManager.createEventObservable('mouseout', this).subscribe(e => this.mouseOut.emit(e));\n      this._observableSubscriptions.push(mout);\n      const anChng = this._markerManager.createEventObservable('animation_changed', this).subscribe(() => {\n        this.animationChange.emit(this.animation);\n      });\n      this._observableSubscriptions.push(anChng);\n    }\n    /** @internal */\n    id() {\n      return this._id;\n    }\n    /** @internal */\n    toString() {\n      return 'AgmMarker-' + this._id.toString();\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._markerManager.deleteMarker(this);\n      // unsubscribe all registered observable subscriptions\n      this._observableSubscriptions.forEach(s => s.unsubscribe());\n    }\n  }\n  AgmMarker.ɵfac = function AgmMarker_Factory(t) {\n    return new (t || AgmMarker)(ɵngcc0.ɵɵdirectiveInject(MarkerManager));\n  };\n  AgmMarker.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmMarker,\n    selectors: [[\"agm-marker\"]],\n    contentQueries: function AgmMarker_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, AgmInfoWindow, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.infoWindow = _t);\n      }\n    },\n    inputs: {\n      draggable: [\"markerDraggable\", \"draggable\"],\n      visible: \"visible\",\n      openInfoWindow: \"openInfoWindow\",\n      opacity: \"opacity\",\n      zIndex: \"zIndex\",\n      clickable: [\"markerClickable\", \"clickable\"],\n      latitude: \"latitude\",\n      longitude: \"longitude\",\n      title: \"title\",\n      label: \"label\",\n      iconUrl: \"iconUrl\",\n      animation: \"animation\"\n    },\n    outputs: {\n      animationChange: \"animationChange\",\n      markerClick: \"markerClick\",\n      markerDblClick: \"markerDblClick\",\n      markerRightClick: \"markerRightClick\",\n      dragStart: \"dragStart\",\n      drag: \"drag\",\n      dragEnd: \"dragEnd\",\n      mouseOver: \"mouseOver\",\n      mouseOut: \"mouseOut\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: FitBoundsAccessor,\n      useExisting: forwardRef(() => AgmMarker)\n    }]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return AgmMarker;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * AgmPolygon renders a polygon on a {@link AgmMap}\n *\n * ### Example\n * ```typescript\n * import { Component } from '@angular/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  styles: [`\n *    agm-map {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <agm-polygon [paths]=\"paths\">\n *      </agm-polygon>\n *    </agm-map>\n *  `\n * })\n * export class MyMapCmp {\n *   lat: number = 0;\n *   lng: number = 0;\n *   zoom: number = 10;\n *   paths: LatLngLiteral[] = [\n *     { lat: 0,  lng: 10 },\n *     { lat: 0,  lng: 20 },\n *     { lat: 10, lng: 20 },\n *     { lat: 10, lng: 10 },\n *     { lat: 0,  lng: 10 }\n *   ]\n *   // Nesting paths will create a hole where they overlap;\n *   nestedPaths: LatLngLiteral[][] = [[\n *     { lat: 0,  lng: 10 },\n *     { lat: 0,  lng: 20 },\n *     { lat: 10, lng: 20 },\n *     { lat: 10, lng: 10 },\n *     { lat: 0,  lng: 10 }\n *   ], [\n *     { lat: 0, lng: 15 },\n *     { lat: 0, lng: 20 },\n *     { lat: 5, lng: 20 },\n *     { lat: 5, lng: 15 },\n *     { lat: 0, lng: 15 }\n *   ]]\n * }\n * ```\n */\nlet AgmPolygon = /*#__PURE__*/(() => {\n  class AgmPolygon {\n    constructor(_polygonManager) {\n      this._polygonManager = _polygonManager;\n      /**\n       * Indicates whether this Polygon handles mouse events. Defaults to true.\n       */\n      this.clickable = true;\n      /**\n       * If set to true, the user can drag this shape over the map. The geodesic\n       * property defines the mode of dragging. Defaults to false.\n       */\n      // tslint:disable-next-line:no-input-rename\n      this.draggable = false;\n      /**\n       * If set to true, the user can edit this shape by dragging the control\n       * points shown at the vertices and on each segment. Defaults to false.\n       */\n      this.editable = false;\n      /**\n       * When true, edges of the polygon are interpreted as geodesic and will\n       * follow the curvature of the Earth. When false, edges of the polygon are\n       * rendered as straight lines in screen space. Note that the shape of a\n       * geodesic polygon may appear to change when dragged, as the dimensions\n       * are maintained relative to the surface of the earth. Defaults to false.\n       */\n      this.geodesic = false;\n      /**\n       * The ordered sequence of coordinates that designates a closed loop.\n       * Unlike polylines, a polygon may consist of one or more paths.\n       *  As a result, the paths property may specify one or more arrays of\n       * LatLng coordinates. Paths are closed automatically; do not repeat the\n       * first vertex of the path as the last vertex. Simple polygons may be\n       * defined using a single array of LatLngs. More complex polygons may\n       * specify an array of arrays. Any simple arrays are converted into Arrays.\n       * Inserting or removing LatLngs from the Array will automatically update\n       * the polygon on the map.\n       */\n      this.paths = [];\n      /**\n       * This event is fired when the DOM click event is fired on the Polygon.\n       */\n      this.polyClick = new EventEmitter();\n      /**\n       * This event is fired when the DOM dblclick event is fired on the Polygon.\n       */\n      this.polyDblClick = new EventEmitter();\n      /**\n       * This event is repeatedly fired while the user drags the polygon.\n       */\n      this.polyDrag = new EventEmitter();\n      /**\n       * This event is fired when the user stops dragging the polygon.\n       */\n      this.polyDragEnd = new EventEmitter();\n      /**\n       * This event is fired when the user starts dragging the polygon.\n       */\n      this.polyDragStart = new EventEmitter();\n      /**\n       * This event is fired when the DOM mousedown event is fired on the Polygon.\n       */\n      this.polyMouseDown = new EventEmitter();\n      /**\n       * This event is fired when the DOM mousemove event is fired on the Polygon.\n       */\n      this.polyMouseMove = new EventEmitter();\n      /**\n       * This event is fired on Polygon mouseout.\n       */\n      this.polyMouseOut = new EventEmitter();\n      /**\n       * This event is fired on Polygon mouseover.\n       */\n      this.polyMouseOver = new EventEmitter();\n      /**\n       * This event is fired whe the DOM mouseup event is fired on the Polygon\n       */\n      this.polyMouseUp = new EventEmitter();\n      /**\n       * This event is fired when the Polygon is right-clicked on.\n       */\n      this.polyRightClick = new EventEmitter();\n      /**\n       * This event is fired after Polygon first path changes.\n       */\n      this.polyPathsChange = new EventEmitter();\n      this._polygonAddedToManager = false;\n      this._subscriptions = [];\n    }\n    /** @internal */\n    ngAfterContentInit() {\n      if (!this._polygonAddedToManager) {\n        this._init();\n      }\n    }\n    ngOnChanges(changes) {\n      if (!this._polygonAddedToManager) {\n        this._init();\n        return;\n      }\n      this._polygonManager.setPolygonOptions(this, this._updatePolygonOptions(changes));\n    }\n    _init() {\n      this._polygonManager.addPolygon(this);\n      this._polygonAddedToManager = true;\n      this._addEventListeners();\n    }\n    _addEventListeners() {\n      const handlers = [{\n        name: 'click',\n        handler: ev => this.polyClick.emit(ev)\n      }, {\n        name: 'dblclick',\n        handler: ev => this.polyDblClick.emit(ev)\n      }, {\n        name: 'drag',\n        handler: ev => this.polyDrag.emit(ev)\n      }, {\n        name: 'dragend',\n        handler: ev => this.polyDragEnd.emit(ev)\n      }, {\n        name: 'dragstart',\n        handler: ev => this.polyDragStart.emit(ev)\n      }, {\n        name: 'mousedown',\n        handler: ev => this.polyMouseDown.emit(ev)\n      }, {\n        name: 'mousemove',\n        handler: ev => this.polyMouseMove.emit(ev)\n      }, {\n        name: 'mouseout',\n        handler: ev => this.polyMouseOut.emit(ev)\n      }, {\n        name: 'mouseover',\n        handler: ev => this.polyMouseOver.emit(ev)\n      }, {\n        name: 'mouseup',\n        handler: ev => this.polyMouseUp.emit(ev)\n      }, {\n        name: 'rightclick',\n        handler: ev => this.polyRightClick.emit(ev)\n      }];\n      handlers.forEach(obj => {\n        const os = this._polygonManager.createEventObservable(obj.name, this).subscribe(obj.handler);\n        this._subscriptions.push(os);\n      });\n      this._polygonManager.createPathEventObservable(this).then(paths$ => {\n        const os = paths$.subscribe(pathEvent => this.polyPathsChange.emit(pathEvent));\n        this._subscriptions.push(os);\n      });\n    }\n    _updatePolygonOptions(changes) {\n      return Object.keys(changes).filter(k => AgmPolygon._polygonOptionsAttributes.indexOf(k) !== -1).reduce((obj, k) => {\n        obj[k] = changes[k].currentValue;\n        return obj;\n      }, {});\n    }\n    /** @internal */\n    id() {\n      return this._id;\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._polygonManager.deletePolygon(this);\n      // unsubscribe all registered observable subscriptions\n      this._subscriptions.forEach(s => s.unsubscribe());\n    }\n    getPath() {\n      return this._polygonManager.getPath(this);\n    }\n    getPaths() {\n      return this._polygonManager.getPaths(this);\n    }\n  }\n  AgmPolygon.ɵfac = function AgmPolygon_Factory(t) {\n    return new (t || AgmPolygon)(ɵngcc0.ɵɵdirectiveInject(PolygonManager));\n  };\n  AgmPolygon.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmPolygon,\n    selectors: [[\"agm-polygon\"]],\n    inputs: {\n      clickable: \"clickable\",\n      draggable: [\"polyDraggable\", \"draggable\"],\n      editable: \"editable\",\n      geodesic: \"geodesic\",\n      paths: \"paths\",\n      fillColor: \"fillColor\",\n      fillOpacity: \"fillOpacity\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      zIndex: \"zIndex\"\n    },\n    outputs: {\n      polyClick: \"polyClick\",\n      polyDblClick: \"polyDblClick\",\n      polyDrag: \"polyDrag\",\n      polyDragEnd: \"polyDragEnd\",\n      polyDragStart: \"polyDragStart\",\n      polyMouseDown: \"polyMouseDown\",\n      polyMouseMove: \"polyMouseMove\",\n      polyMouseOut: \"polyMouseOut\",\n      polyMouseOver: \"polyMouseOver\",\n      polyMouseUp: \"polyMouseUp\",\n      polyRightClick: \"polyRightClick\",\n      polyPathsChange: \"polyPathsChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  AgmPolygon._polygonOptionsAttributes = ['clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'icon', 'map', 'paths', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'draggable', 'editable', 'visible'];\n  return AgmPolygon;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * AgmPolylineIcon enables to add polyline sequences to add arrows, circle,\n * or custom icons either along the entire line, or in a specific part of it.\n * See https://developers.google.com/maps/documentation/javascript/shapes#polyline_customize\n *\n * ### Example\n * ```html\n *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <agm-polyline>\n *          <agm-icon-sequence [fixedRotation]=\"true\" [path]=\"'FORWARD_OPEN_ARROW'\">\n *          </agm-icon-sequence>\n *      </agm-polyline>\n *    </agm-map>\n * ```\n */\nlet AgmPolylineIcon = /*#__PURE__*/(() => {\n  class AgmPolylineIcon {\n    ngOnInit() {\n      if (this.path == null) {\n        throw new Error('Icon Sequence path is required');\n      }\n    }\n  }\n  AgmPolylineIcon.ɵfac = function AgmPolylineIcon_Factory(t) {\n    return new (t || AgmPolylineIcon)();\n  };\n  AgmPolylineIcon.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmPolylineIcon,\n    selectors: [[\"agm-icon-sequence\"]],\n    inputs: {\n      fixedRotation: \"fixedRotation\",\n      offset: \"offset\",\n      repeat: \"repeat\",\n      anchorX: \"anchorX\",\n      anchorY: \"anchorY\",\n      fillColor: \"fillColor\",\n      fillOpacity: \"fillOpacity\",\n      path: \"path\",\n      rotation: \"rotation\",\n      scale: \"scale\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokeWeight: \"strokeWeight\"\n    }\n  });\n  return AgmPolylineIcon;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * AgmPolylinePoint represents one element of a polyline within a  {@link\n * AgmPolyline}\n */\nlet AgmPolylinePoint = /*#__PURE__*/(() => {\n  class AgmPolylinePoint {\n    constructor() {\n      /**\n       * This event emitter gets emitted when the position of the point changed.\n       */\n      this.positionChanged = new EventEmitter();\n    }\n    ngOnChanges(changes) {\n      // tslint:disable: no-string-literal\n      if (changes['latitude'] || changes['longitude']) {\n        this.positionChanged.emit({\n          lat: changes['latitude'] ? changes['latitude'].currentValue : this.latitude,\n          lng: changes['longitude'] ? changes['longitude'].currentValue : this.longitude\n        });\n      }\n      // tslint:enable: no-string-literal\n    }\n    /** @internal */\n    getFitBoundsDetails$() {\n      return this.positionChanged.pipe(startWith({\n        lat: this.latitude,\n        lng: this.longitude\n      }), map(position => ({\n        latLng: position\n      })));\n    }\n  }\n  AgmPolylinePoint.ɵfac = function AgmPolylinePoint_Factory(t) {\n    return new (t || AgmPolylinePoint)();\n  };\n  AgmPolylinePoint.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmPolylinePoint,\n    selectors: [[\"agm-polyline-point\"]],\n    inputs: {\n      latitude: \"latitude\",\n      longitude: \"longitude\"\n    },\n    outputs: {\n      positionChanged: \"positionChanged\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: FitBoundsAccessor,\n      useExisting: forwardRef(() => AgmPolylinePoint)\n    }]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return AgmPolylinePoint;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet polylineId = 0;\n/**\n * AgmPolyline renders a polyline on a {@link AgmMap}\n *\n * ### Example\n * ```typescript\n * import { Component } from '@angular/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  styles: [`\n *    .agm-map-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <agm-polyline>\n *          <agm-polyline-point [latitude]=\"latA\" [longitude]=\"lngA\">\n *          </agm-polyline-point>\n *          <agm-polyline-point [latitude]=\"latB\" [longitude]=\"lngB\">\n *          </agm-polyline-point>\n *      </agm-polyline>\n *    </agm-map>\n *  `\n * })\n * ```\n */\nlet AgmPolyline = /*#__PURE__*/(() => {\n  class AgmPolyline {\n    constructor(_polylineManager) {\n      this._polylineManager = _polylineManager;\n      /**\n       * Indicates whether this Polyline handles mouse events. Defaults to true.\n       */\n      this.clickable = true;\n      /**\n       * If set to true, the user can drag this shape over the map. The geodesic property defines the\n       * mode of dragging. Defaults to false.\n       */\n      // tslint:disable-next-line:no-input-rename\n      this.draggable = false;\n      /**\n       * If set to true, the user can edit this shape by dragging the control points shown at the\n       * vertices and on each segment. Defaults to false.\n       */\n      this.editable = false;\n      /**\n       * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of\n       * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.\n       * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions\n       * are maintained relative to the surface of the earth. Defaults to false.\n       */\n      this.geodesic = false;\n      /**\n       * Whether this polyline is visible on the map. Defaults to true.\n       */\n      this.visible = true;\n      /**\n       * This event is fired when the DOM click event is fired on the Polyline.\n       */\n      this.lineClick = new EventEmitter();\n      /**\n       * This event is fired when the DOM dblclick event is fired on the Polyline.\n       */\n      this.lineDblClick = new EventEmitter();\n      /**\n       * This event is repeatedly fired while the user drags the polyline.\n       */\n      this.lineDrag = new EventEmitter();\n      /**\n       * This event is fired when the user stops dragging the polyline.\n       */\n      this.lineDragEnd = new EventEmitter();\n      /**\n       * This event is fired when the user starts dragging the polyline.\n       */\n      this.lineDragStart = new EventEmitter();\n      /**\n       * This event is fired when the DOM mousedown event is fired on the Polyline.\n       */\n      this.lineMouseDown = new EventEmitter();\n      /**\n       * This event is fired when the DOM mousemove event is fired on the Polyline.\n       */\n      this.lineMouseMove = new EventEmitter();\n      /**\n       * This event is fired on Polyline mouseout.\n       */\n      this.lineMouseOut = new EventEmitter();\n      /**\n       * This event is fired on Polyline mouseover.\n       */\n      this.lineMouseOver = new EventEmitter();\n      /**\n       * This event is fired whe the DOM mouseup event is fired on the Polyline\n       */\n      this.lineMouseUp = new EventEmitter();\n      /**\n       * This event is fired when the Polyline is right-clicked on.\n       */\n      this.lineRightClick = new EventEmitter();\n      /**\n       * This event is fired after Polyline's path changes.\n       */\n      this.polyPathChange = new EventEmitter();\n      this._polylineAddedToManager = false;\n      this._subscriptions = [];\n      this._id = (polylineId++).toString();\n    }\n    /** @internal */\n    ngAfterContentInit() {\n      if (this.points.length) {\n        this.points.forEach(point => {\n          const s = point.positionChanged.subscribe(() => {\n            this._polylineManager.updatePolylinePoints(this);\n          });\n          this._subscriptions.push(s);\n        });\n      }\n      if (!this._polylineAddedToManager) {\n        this._init();\n      }\n      const pointSub = this.points.changes.subscribe(() => this._polylineManager.updatePolylinePoints(this));\n      this._subscriptions.push(pointSub);\n      this._polylineManager.updatePolylinePoints(this);\n      const iconSub = this.iconSequences.changes.subscribe(() => this._polylineManager.updateIconSequences(this));\n      this._subscriptions.push(iconSub);\n    }\n    ngOnChanges(changes) {\n      if (!this._polylineAddedToManager) {\n        this._init();\n        return;\n      }\n      const options = {};\n      const optionKeys = Object.keys(changes).filter(k => AgmPolyline._polylineOptionsAttributes.indexOf(k) !== -1);\n      optionKeys.forEach(k => options[k] = changes[k].currentValue);\n      this._polylineManager.setPolylineOptions(this, options);\n    }\n    getPath() {\n      return this._polylineManager.getPath(this);\n    }\n    _init() {\n      this._polylineManager.addPolyline(this);\n      this._polylineAddedToManager = true;\n      this._addEventListeners();\n    }\n    _addEventListeners() {\n      const handlers = [{\n        name: 'click',\n        handler: ev => this.lineClick.emit(ev)\n      }, {\n        name: 'dblclick',\n        handler: ev => this.lineDblClick.emit(ev)\n      }, {\n        name: 'drag',\n        handler: ev => this.lineDrag.emit(ev)\n      }, {\n        name: 'dragend',\n        handler: ev => this.lineDragEnd.emit(ev)\n      }, {\n        name: 'dragstart',\n        handler: ev => this.lineDragStart.emit(ev)\n      }, {\n        name: 'mousedown',\n        handler: ev => this.lineMouseDown.emit(ev)\n      }, {\n        name: 'mousemove',\n        handler: ev => this.lineMouseMove.emit(ev)\n      }, {\n        name: 'mouseout',\n        handler: ev => this.lineMouseOut.emit(ev)\n      }, {\n        name: 'mouseover',\n        handler: ev => this.lineMouseOver.emit(ev)\n      }, {\n        name: 'mouseup',\n        handler: ev => this.lineMouseUp.emit(ev)\n      }, {\n        name: 'rightclick',\n        handler: ev => this.lineRightClick.emit(ev)\n      }];\n      handlers.forEach(obj => {\n        const os = this._polylineManager.createEventObservable(obj.name, this).subscribe(obj.handler);\n        this._subscriptions.push(os);\n      });\n      this._polylineManager.createPathEventObservable(this).then(ob$ => {\n        const os = ob$.subscribe(pathEvent => this.polyPathChange.emit(pathEvent));\n        this._subscriptions.push(os);\n      });\n    }\n    /** @internal */\n    _getPoints() {\n      if (this.points) {\n        return this.points.toArray();\n      }\n      return [];\n    }\n    _getIcons() {\n      if (this.iconSequences) {\n        return this.iconSequences.toArray();\n      }\n      return [];\n    }\n    /** @internal */\n    id() {\n      return this._id;\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._polylineManager.deletePolyline(this);\n      // unsubscribe all registered observable subscriptions\n      this._subscriptions.forEach(s => s.unsubscribe());\n    }\n  }\n  AgmPolyline.ɵfac = function AgmPolyline_Factory(t) {\n    return new (t || AgmPolyline)(ɵngcc0.ɵɵdirectiveInject(PolylineManager));\n  };\n  AgmPolyline.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmPolyline,\n    selectors: [[\"agm-polyline\"]],\n    contentQueries: function AgmPolyline_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, AgmPolylinePoint, 4);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, AgmPolylineIcon, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.points = _t);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.iconSequences = _t);\n      }\n    },\n    inputs: {\n      clickable: \"clickable\",\n      draggable: [\"polylineDraggable\", \"draggable\"],\n      editable: \"editable\",\n      geodesic: \"geodesic\",\n      visible: \"visible\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokeWeight: \"strokeWeight\",\n      zIndex: \"zIndex\"\n    },\n    outputs: {\n      lineClick: \"lineClick\",\n      lineDblClick: \"lineDblClick\",\n      lineDrag: \"lineDrag\",\n      lineDragEnd: \"lineDragEnd\",\n      lineDragStart: \"lineDragStart\",\n      lineMouseDown: \"lineMouseDown\",\n      lineMouseMove: \"lineMouseMove\",\n      lineMouseOut: \"lineMouseOut\",\n      lineMouseOver: \"lineMouseOver\",\n      lineMouseUp: \"lineMouseUp\",\n      lineRightClick: \"lineRightClick\",\n      polyPathChange: \"polyPathChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  AgmPolyline._polylineOptionsAttributes = ['draggable', 'editable', 'visible', 'geodesic', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'zIndex'];\n  return AgmPolyline;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AgmRectangle = /*#__PURE__*/(() => {\n  class AgmRectangle {\n    constructor(_manager) {\n      this._manager = _manager;\n      /**\n       * Indicates whether this Rectangle handles mouse events. Defaults to true.\n       */\n      this.clickable = true;\n      /**\n       * If set to true, the user can drag this rectangle over the map. Defaults to false.\n       */\n      // tslint:disable-next-line:no-input-rename\n      this.draggable = false;\n      /**\n       * If set to true, the user can edit this rectangle by dragging the control points shown at\n       * the center and around the circumference of the rectangle. Defaults to false.\n       */\n      this.editable = false;\n      /**\n       * The stroke position. Defaults to CENTER.\n       * This property is not supported on Internet Explorer 8 and earlier.\n       */\n      this.strokePosition = 'CENTER';\n      /**\n       * The stroke width in pixels.\n       */\n      this.strokeWeight = 0;\n      /**\n       * Whether this rectangle is visible on the map. Defaults to true.\n       */\n      this.visible = true;\n      /**\n       * This event is fired when the rectangle's is changed.\n       */\n      this.boundsChange = new EventEmitter();\n      /**\n       * This event emitter gets emitted when the user clicks on the rectangle.\n       */\n      this.rectangleClick = new EventEmitter();\n      /**\n       * This event emitter gets emitted when the user clicks on the rectangle.\n       */\n      this.rectangleDblClick = new EventEmitter();\n      /**\n       * This event is repeatedly fired while the user drags the rectangle.\n       */\n      // tslint:disable-next-line: no-output-native\n      this.drag = new EventEmitter();\n      /**\n       * This event is fired when the user stops dragging the rectangle.\n       */\n      this.dragEnd = new EventEmitter();\n      /**\n       * This event is fired when the user starts dragging the rectangle.\n       */\n      this.dragStart = new EventEmitter();\n      /**\n       * This event is fired when the DOM mousedown event is fired on the rectangle.\n       */\n      this.mouseDown = new EventEmitter();\n      /**\n       * This event is fired when the DOM mousemove event is fired on the rectangle.\n       */\n      this.mouseMove = new EventEmitter();\n      /**\n       * This event is fired on rectangle mouseout.\n       */\n      this.mouseOut = new EventEmitter();\n      /**\n       * This event is fired on rectangle mouseover.\n       */\n      this.mouseOver = new EventEmitter();\n      /**\n       * This event is fired when the DOM mouseup event is fired on the rectangle.\n       */\n      this.mouseUp = new EventEmitter();\n      /**\n       * This event is fired when the rectangle is right-clicked on.\n       */\n      this.rightClick = new EventEmitter();\n      this._rectangleAddedToManager = false;\n      this._eventSubscriptions = [];\n    }\n    /** @internal */\n    ngOnInit() {\n      this._manager.addRectangle(this);\n      this._rectangleAddedToManager = true;\n      this._registerEventListeners();\n    }\n    /** @internal */\n    ngOnChanges(changes) {\n      if (!this._rectangleAddedToManager) {\n        return;\n      }\n      // tslint:disable: no-string-literal\n      if (changes['north'] || changes['east'] || changes['south'] || changes['west']) {\n        this._manager.setBounds(this);\n      }\n      if (changes['editable']) {\n        this._manager.setEditable(this);\n      }\n      if (changes['draggable']) {\n        this._manager.setDraggable(this);\n      }\n      if (changes['visible']) {\n        this._manager.setVisible(this);\n      }\n      // tslint:enable: no-string-literal\n      this._updateRectangleOptionsChanges(changes);\n    }\n    _updateRectangleOptionsChanges(changes) {\n      const options = {};\n      const optionKeys = Object.keys(changes).filter(k => AgmRectangle._mapOptions.indexOf(k) !== -1);\n      optionKeys.forEach(k => {\n        options[k] = changes[k].currentValue;\n      });\n      if (optionKeys.length > 0) {\n        this._manager.setOptions(this, options);\n      }\n    }\n    _registerEventListeners() {\n      const events = new Map();\n      events.set('bounds_changed', this.boundsChange);\n      events.set('click', this.rectangleClick);\n      events.set('dblclick', this.rectangleDblClick);\n      events.set('drag', this.drag);\n      events.set('dragend', this.dragEnd);\n      events.set('dragStart', this.dragStart);\n      events.set('mousedown', this.mouseDown);\n      events.set('mousemove', this.mouseMove);\n      events.set('mouseout', this.mouseOut);\n      events.set('mouseover', this.mouseOver);\n      events.set('mouseup', this.mouseUp);\n      events.set('rightclick', this.rightClick);\n      events.forEach((eventEmitter, eventName) => {\n        this._eventSubscriptions.push(this._manager.createEventObservable(eventName, this).subscribe(value => {\n          switch (eventName) {\n            case 'bounds_changed':\n              this._manager.getBounds(this).then(bounds => eventEmitter.emit({\n                north: bounds.getNorthEast().lat(),\n                east: bounds.getNorthEast().lng(),\n                south: bounds.getSouthWest().lat(),\n                west: bounds.getSouthWest().lng()\n              }));\n              break;\n            default:\n              eventEmitter.emit(value);\n          }\n        }));\n      });\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._eventSubscriptions.forEach(s => s.unsubscribe());\n      this._eventSubscriptions = null;\n      this._manager.removeRectangle(this);\n    }\n    /**\n     * Gets the LatLngBounds of this Rectangle.\n     */\n    getBounds() {\n      return this._manager.getBounds(this);\n    }\n  }\n  AgmRectangle.ɵfac = function AgmRectangle_Factory(t) {\n    return new (t || AgmRectangle)(ɵngcc0.ɵɵdirectiveInject(RectangleManager));\n  };\n  AgmRectangle.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmRectangle,\n    selectors: [[\"agm-rectangle\"]],\n    inputs: {\n      clickable: \"clickable\",\n      draggable: [\"rectangleDraggable\", \"draggable\"],\n      editable: \"editable\",\n      strokePosition: \"strokePosition\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      north: \"north\",\n      east: \"east\",\n      south: \"south\",\n      west: \"west\",\n      fillColor: \"fillColor\",\n      fillOpacity: \"fillOpacity\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      zIndex: \"zIndex\"\n    },\n    outputs: {\n      boundsChange: \"boundsChange\",\n      rectangleClick: \"rectangleClick\",\n      rectangleDblClick: \"rectangleDblClick\",\n      drag: \"drag\",\n      dragEnd: \"dragEnd\",\n      dragStart: \"dragStart\",\n      mouseDown: \"mouseDown\",\n      mouseMove: \"mouseMove\",\n      mouseOut: \"mouseOut\",\n      mouseOver: \"mouseOver\",\n      mouseUp: \"mouseUp\",\n      rightClick: \"rightClick\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  AgmRectangle._mapOptions = ['fillColor', 'fillOpacity', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'clickable'];\n  return AgmRectangle;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet layerId$3 = 0;\n/*\n * This directive adds a transit layer to a google map instance\n * <agm-transit-layer [visible]=\"true|false\"> <agm-transit-layer>\n * */\nlet AgmTransitLayer = /*#__PURE__*/(() => {\n  class AgmTransitLayer {\n    constructor(_manager) {\n      this._manager = _manager;\n      this._addedToManager = false;\n      this._id = (layerId$3++).toString();\n      /**\n       * Hide/show transit layer\n       */\n      this.visible = true;\n    }\n    ngOnInit() {\n      if (this._addedToManager) {\n        return;\n      }\n      this._manager.addTransitLayer(this);\n      this._addedToManager = true;\n    }\n    /** @internal */\n    id() {\n      return this._id;\n    }\n    /** @internal */\n    toString() {\n      return `AgmTransitLayer-${this._id.toString()}`;\n    }\n    /** @internal */\n    ngOnDestroy() {\n      this._manager.deleteLayer(this);\n    }\n  }\n  AgmTransitLayer.ɵfac = function AgmTransitLayer_Factory(t) {\n    return new (t || AgmTransitLayer)(ɵngcc0.ɵɵdirectiveInject(LayerManager));\n  };\n  AgmTransitLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmTransitLayer,\n    selectors: [[\"agm-transit-layer\"]],\n    inputs: {\n      visible: \"visible\"\n    }\n  });\n  return AgmTransitLayer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @internal\n */\nfunction coreDirectives() {\n  return [AgmBicyclingLayer, AgmCircle, AgmDataLayer, AgmFitBounds, AgmFullscreenControl, AgmInfoWindow, AgmKmlLayer, AgmMap, AgmMapTypeControl, AgmMarker, AgmPanControl, AgmPolygon, AgmPolyline, AgmPolylineIcon, AgmPolylinePoint, AgmRectangle, AgmRotateControl, AgmScaleControl, AgmStreetViewControl, AgmTransitLayer, AgmZoomControl];\n}\n/**\n * The angular-google-maps core module. Contains all Directives/Services/Pipes\n * of the core module. Please use `AgmCoreModule.forRoot()` in your app module.\n */\nlet AgmCoreModule = /*#__PURE__*/(() => {\n  class AgmCoreModule {\n    /**\n     * Please use this method when you register the module at the root level.\n     */\n    static forRoot(lazyMapsAPILoaderConfig) {\n      return {\n        ngModule: AgmCoreModule,\n        providers: [...BROWSER_GLOBALS_PROVIDERS, {\n          provide: MapsAPILoader,\n          useClass: LazyMapsAPILoader\n        }, {\n          provide: LAZY_MAPS_API_CONFIG,\n          useValue: lazyMapsAPILoaderConfig\n        }]\n      };\n    }\n  }\n  AgmCoreModule.ɵfac = function AgmCoreModule_Factory(t) {\n    return new (t || AgmCoreModule)();\n  };\n  AgmCoreModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AgmCoreModule\n  });\n  AgmCoreModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return AgmCoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AgmCoreModule, {\n    declarations: [AgmBicyclingLayer, AgmCircle, AgmDataLayer, AgmFitBounds, AgmFullscreenControl, AgmInfoWindow, AgmKmlLayer, AgmMap, AgmMapTypeControl, AgmMarker, AgmPanControl, AgmPolygon, AgmPolyline, AgmPolylineIcon, AgmPolylinePoint, AgmRectangle, AgmRotateControl, AgmScaleControl, AgmStreetViewControl, AgmTransitLayer, AgmZoomControl],\n    exports: [AgmBicyclingLayer, AgmCircle, AgmDataLayer, AgmFitBounds, AgmFullscreenControl, AgmInfoWindow, AgmKmlLayer, AgmMap, AgmMapTypeControl, AgmMarker, AgmPanControl, AgmPolygon, AgmPolyline, AgmPolylineIcon, AgmPolylinePoint, AgmRectangle, AgmRotateControl, AgmScaleControl, AgmStreetViewControl, AgmTransitLayer, AgmZoomControl]\n  });\n})();\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AgmBicyclingLayer, AgmCircle, AgmCoreModule, AgmDataLayer, AgmFitBounds, AgmFullscreenControl, AgmGeocoder, AgmInfoWindow, AgmKmlLayer, AgmMap, AgmMapTypeControl, AgmMarker, AgmPanControl, AgmPolygon, AgmPolyline, AgmPolylineIcon, AgmPolylinePoint, AgmRectangle, AgmRotateControl, AgmScaleControl, AgmStreetViewControl, AgmTransitLayer, AgmZoomControl, CircleManager, DataLayerManager, FitBoundsAccessor, GoogleMapsAPIWrapper, GoogleMapsScriptProtocol, InfoWindowManager, KmlLayerManager, LAZY_MAPS_API_CONFIG, LayerManager, LazyMapsAPILoader, MapsAPILoader, MarkerManager, NoOpMapsAPILoader, PolygonManager, PolylineManager, RectangleManager, coreDirectives, FitBoundsService as ɵa, AgmMapControl as ɵb, WindowRef as ɵc, DocumentRef as ɵd, BROWSER_GLOBALS_PROVIDERS as ɵe };\n\n//# sourceMappingURL=agm-core.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}